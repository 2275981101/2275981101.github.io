<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>welcome</title>
  
  <subtitle>求知若饥，虚心若愚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-14T02:46:15.375Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wanghai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS3动画</title>
    <link href="http://yoursite.com/2018/12/13/CSS3%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/12/13/CSS3动画/</id>
    <published>2018-12-13T09:55:59.000Z</published>
    <updated>2018-12-14T02:46:15.375Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CSS3，我们可以创建动画，它可以取代许多网页动画图像，Flash动画，和JAVAScripts。</strong></p><style>            #ppxiong{                width: 76px;                height: 47px;                background: #92B901 none repeat scroll 0% 0%;                position: relative;                color: #fff;                font-weight: bold;                font-size: 20px;                padding: 10px;                border-radius: 5px;                animation: first 5s ease 0s normal none 3 running;            }            @keyframes first            {                0% {background: red;  transform: rotate(0deg);left: 0;}                25%{background: pink; transform: rotate(20deg);left: 0;}                50%{background: blue; transform: rotate(0deg);left: 500px;}                55%{background: green; transform: rotate(0deg);left: 500px;}                70%{background: #1ec7e6; transform: rotate(0deg);left: 500px;}                100% {background: yellow; transform: rotate(-360deg);left: 0;}            }</style><div id="ppxiong">CSS3</div><p>浏览器支持<br>Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。</p><p>当在@keyframe创建动画，把它绑定到一个选择器，否则动画不会有任何效果。<br>指定至少这两个CSS3的动画属性绑定向一个选择器：</p><ul><li><p>规定动画的名称</p></li><li><p>规定动画的时长</p></li></ul><style>        #showtime{            width: 100px;            height: 100px;            background: red;            animation: myfirst 5s;        }        @keyframes myfirst        {            from {background: red;}            to {background: yellow;}        }</style><div id="showtime"></div><pre><code>把 &quot;myfirst&quot; 动画捆绑到 div 元素，时长：5 秒：&lt;style&gt;   div{        width: 100px;        height: 100px;        background: red;        animation: myfirst 5s;    }   @keyframes myfirst   {        from {background:red;}        to {background:yellow;}    }&lt;/style&gt;&lt;div&gt;&lt;/div&gt;</code></pre><p>必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。</p><font color="red"><strong>CSS3动画是什么？</strong></font><p>• 动画是使元素从一种样式逐渐变化为另一种样式的效果。</p><p>• 您可以改变任意多的样式任意多的次数。</p><p>• 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p><p>• 0% 是动画的开始，100% 是动画的完成。</p><p>• 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p><pre><code>&lt;style&gt; div{    width:100px;    height:100px;    background:red;    animation:myfirst 5s;    -moz-animation:myfirst 5s; /* Firefox */    -webkit-animation:myfirst 5s; /* Safari and Chrome */    -o-animation:myfirst 5s; /* Opera */}@keyframes myfirst{    0%   {background:red;}    25%  {background:yellow;}    50%  {background:blue;}    100% {background:green;}}@-moz-keyframes myfirst /* Firefox */{    0%   {background:red;}    25%  {background:yellow;}    50%  {background:blue;}    100% {background:green;}}@-webkit-keyframes myfirst /* Safari and Chrome */{    0%   {background:red;}    25%  {background:yellow;}    50%  {background:blue;}    100% {background:green;}}@-o-keyframes myfirst /* Opera */{    0%   {background:red;}    25%  {background:yellow;}    50%  {background:blue;}    100% {background:green;}}&lt;/style&gt;&lt;div&gt;&lt;/div&gt; </code></pre><font color="red"><strong>CSS3的动画属性</strong></font><pre><code>@keyframes                  关键帧: 规定动画animation                   所有动画属性的简写属性,除了animation-play-state animation-name              规定 @keyframes 动画的名称animation-duration          规定动画完成一个周期所花费的秒或毫秒。默认是 0animation-timing-function   规定动画的速度曲线(运动速度函数)。默认是 &quot;ease&quot;animation-delay             规定动画何时开始(延迟时间)。默认是 0animation-iteration-count   规定动画执行的次数  infinite(无限循环)animation-direction         规定动画是否在下一周期逆向地播放。默认是 &quot;normal&quot;animation-fill-mode         属性规定动画在播放之前或之后，其动画效果是否可见animation-play-state        规定动画是否正在运行或暂停。默认是 &quot;running&quot;</code></pre><style>    #CSS3animation{        width: 100px;        height: 100px;        background: red;        position: relative;        animation: animationdemo 3s ease 2s infinite alternate-reverse running;    }      @keyframes animationdemo    {        0%   {background:red; left:0px; top:0px;}        15%  {background:yellow; left:300px; top:0px;}        30%  {background:blue; left:300px; top:100px;}        45%  {background:green; left:600px; top:100px;}        60%  {background:green; left:300px; top:100px;}        75%  {background:yellow; left:300px; top:0px;}        100%   {background:red; left:0px; top:0px;}    }    @-webkit-keyframes animationdemo    {        0%   {background:red; left:0px; top:0px;}        15%  {background:yellow; left:300px; top:0px;}        30%  {background:blue; left:300px; top:100px;}        45%  {background:green; left:600px; top:100px;}        60%  {background:green; left:300px; top:100px;}        75%  {background:yellow; left:300px; top:0px;}        100%   {background:red; left:0px; top:0px;}    }   </style><div id="CSS3animation"></div><pre><code>&lt;style&gt;#demo{    width: 100px;    height: 100px;    background: red;    position: relative;    animation: animationdemo 3s ease 2s infinite alternate-reverse running;}  @keyframes animationdemo{    0%   {background:red; left:0px; top:0px;}    15%  {background:yellow; left:300px; top:0px;}    30%  {background:blue; left:300px; top:100px;}    45%  {background:green; left:600px; top:100px;}    60%  {background:green; left:300px; top:100px;}    75%  {background:yellow; left:300px; top:0px;}    100%   {background:red; left:0px; top:0px;}}@-webkit-keyframes animationdemo{    0%   {background:red; left:0px; top:0px;}    15%  {background:yellow; left:300px; top:0px;}    30%  {background:blue; left:300px; top:100px;}    45%  {background:green; left:600px; top:100px;}    60%  {background:green; left:300px; top:100px;}    75%  {background:yellow; left:300px; top:0px;}    100%   {background:red; left:0px; top:0px;}}   &lt;/style&gt;&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;CSS3，我们可以创建动画，它可以取代许多网页动画图像，Flash动画，和JAVAScripts。&lt;/strong&gt;&lt;/p&gt;
&lt;style&gt;
            #ppxiong{
                width: 76px;
       
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3渐变</title>
    <link href="http://yoursite.com/2018/12/12/CSS3%E6%B8%90%E5%8F%98/"/>
    <id>http://yoursite.com/2018/12/12/CSS3渐变/</id>
    <published>2018-12-12T09:55:59.000Z</published>
    <updated>2018-12-14T08:49:34.455Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CSS3-渐变（Gradients）"><a href="#CSS3-渐变（Gradients）" class="headerlink" title="CSS3 渐变（Gradients）"></a>CSS3 渐变（Gradients）</h4><div id="gradl11" style="font-size: 36px ;text-align: center;height: 55px;line-height:55px;background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);">Gradient Background</div><ul><li>CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。</li><li>以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的事件和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。</li><li>CSS3 定义了两种类型的渐变（gradients）：<br>1.<font color="red"><strong>线性渐变（Linear Gradients）</strong></font>- 向下/向上/向左/向右/对角方向<br>2.<font color="red"><strong>径向渐变（Radial Gradients）</strong></font>- 由它们的中心定义</li></ul><p><strong>浏览器支持</strong></p><p>后边跟 -webkit-、-moz- 或 -o- 的数字指定了需加上前缀才能支持属性的第一个版本。</p><p>完全支持该属性(4个属性)的第一个浏览器版本。</p><pre><code>IE          10.0chrome      26.0  10.0-webkit-Firefox     16.0  3.6 -moz-Safari      6.1   5.1 -webkit-Opera       12.1  11.1 -o-</code></pre><h4 id="CSS3-线性渐变"><a href="#CSS3-线性渐变" class="headerlink" title="CSS3 线性渐变"></a>CSS3 线性渐变</h4><p>为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。</p><p><strong>语法</strong></p><pre><code>background: linear-gradient(direction, color-stop1, color-stop2, ...);  </code></pre><p><strong>线性渐变 - 从上到下（默认情况下）</strong></p><div id="gradl1" style="height: 200px;background: linear-gradient(red, blue);"></div><pre><code>&lt;style&gt;    #grad1 {        height: 200px;        background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */        background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */        background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */        background: linear-gradient(red, blue); /* 标准的语法（必须放在最后） */    }&lt;/style&gt;&lt;div id=&quot;grad1&quot;&gt;&lt;/div&gt;</code></pre><p><strong>线性渐变 - 从左到右</strong></p><div style="height: 200px; background: linear-gradient(to right, red, blue);"></div><pre><code>#grad1 {    height: 200px;    background: linear-gradient(to right, red , blue); }</code></pre><p><strong>线性渐变 - 对角</strong><br>从左上角开始（到右下角）的线性渐变。起点是红色，慢慢过渡到蓝色：</p><div style="height: 200px;background: linear-gradient(to bottom right, red, blue);"></div><pre><code>#grad1 {    height: 200px;    background: linear-gradient(to bottom right, red , blue); }</code></pre><p><strong>使用角度</strong></p><p>如果你想要在渐变的方向上做更多的控制，你可以定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）。</p><pre><code>background: linear-gradient(angle, color-stop1, color-stop2);     </code></pre><p>角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。</p><p><img src="https://i.imgur.com/NhvHymM.png" alt=""></p><p>下面的实例演示了如何在线性渐变上使用角度：</p><pre><code>0deg - 从下到上background: linear-gradient(0deg, red, blue);</code></pre><div style="height: 100px;background: linear-gradient(0deg, red, blue);"></div><pre><code>90deg - 从左到右background: linear-gradient(90deg, red, blue);</code></pre><div style="height: 100px;background: linear-gradient(90deg, red, blue);"></div><br>        180deg - 从上到下<br>        background: linear-gradient(180deg, red, blue);<br><div style="height: 100px;background: linear-gradient(180deg, red, blue);"></div><br>        -90deg - 从右到左<br>        background: linear-gradient(-90deg, red, blue);<br><div style="height: 100px;background: linear-gradient(-90deg, red, blue);"></div><br><br><br><br><strong>使用多个颜色结点</strong><br><br><br><div style=" height: 200px;background: linear-gradient(red, green, blue);"></div>    <pre><code>3 个颜色结点（均匀分布）background: linear-gradient(red, green, blue);</code></pre><div style="height: 200px;background: linear-gradient(red 10%, green 85%, blue 90%);"></div><pre><code>3 个颜色结点（不均匀分布）background: linear-gradient(red 10%, green 85%, blue 90%);</code></pre><div style="height: 200px;background: linear-gradient(red, orange,  yellow, green, blue,indigo, violet);"></div><pre><code>7 个颜色结点（均匀分布）background: linear-gradient(red, orange,  yellow, green, blue, indigo, violet);</code></pre><h4 id="创建一个带有彩虹颜色和文本的线性渐变"><a href="#创建一个带有彩虹颜色和文本的线性渐变" class="headerlink" title="创建一个带有彩虹颜色和文本的线性渐变"></a>创建一个带有彩虹颜色和文本的线性渐变</h4><pre><code>#grad1 {    height: 55px;    background: -webkit-linear-gradient(left, red, orange, yellow, green, blue, indigo, violet); /* Safari 5.1 - 6.0 */    background: -o-linear-gradient(left, red, orange, yellow, green, blue, indigo, violet); /* Opera 11.1 - 12.0 */    background: -moz-linear-gradient(left, red, orange, yellow, green, blue, indigo, violet); /* Firefox 3.6 - 15 */    background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet); /* 标准的语法（必须放在最后） */}</code></pre><p><strong>使用透明度（Transparency）</strong></p><p>CSS3 渐变也支持透明度（transparency），可用于创建减弱变淡的效果。</p><p>为了添加透明度，我们使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。</p><p>下面的实例演示了从左边开始的线性渐变。起点是完全透明，慢慢过渡到完全不透明的红色：</p><div style="height: 200px;background: linear-gradient(to right, rgba(255, 0, 0, 0), rgba(255, 0, 0, 1));"></div><pre><code>background: linear-gradient(to right, rgba(255, 0, 0, 0), rgba(255, 0, 0, 1));</code></pre><p><strong>重复的线性渐变</strong></p><p>repeating-linear-gradient() 函数用于重复线性渐变：</p><div style="height: 200px;background: repeating-linear-gradient(red, yellow 10%, green 20%);"></div><pre><code>background: repeating-linear-gradient(red, yellow 10%, green 20%);</code></pre><h4 id="CSS3-径向渐变"><a href="#CSS3-径向渐变" class="headerlink" title="CSS3 径向渐变"></a>CSS3 径向渐变</h4><p>径向渐变由它的中心定义。</p><p>为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p><p><strong>语法</strong></p><pre><code>background: radial-gradient(center, shape size, start-color, ..., last-color);</code></pre><p><strong>径向渐变 - 颜色结点均匀分布（默认情况下）</strong></p><div style="height: 150px;width: 200px;background: radial-gradient(red, orange, violet);"></div><pre><code>#gradl1{       height: 150px;       width: 200px;       background: radial-gradient(red, orange, violet);   }   </code></pre><p><strong>径向渐变 - 颜色结点不均匀分布</strong></p><div style="height: 150px;width: 200px;background: radial-gradient(red 5%, orange 15%, violet 60%);"></div><pre><code>#gradl1{       height: 150px;       width: 200px;       background: radial-gradient(red 5%, orange 15%, violet 60%);   } </code></pre><p><strong>设置形状</strong></p><p>shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。</p><div style="height: 150px;width: 200px;background: radial-gradient( red, yellow, green);"></div><pre><code>#gradl1{        height: 150px;        width: 200px;        background: radial-gradient(red, yellow, green);    }</code></pre><div style="height: 150px;width: 200px;background: radial-gradient(circle ,  red, yellow, green);"></div><pre><code>#gradl1{        height: 150px;        width: 200px;        background: radial-gradient(circle, red, yellow, green);    }</code></pre><p><strong>不同尺寸大小关键字的使用</strong></p><p>size 参数定义了渐变的大小。它可以是以下四个值：</p><p><strong>• closest-side</strong><br><strong>• farthest-side</strong><br><strong>• closest-corner</strong><br><strong>• farthest-corner</strong></p><div style="height: 150px;width: 150px;background: -webkit-radial-gradient(60% 55%, closest-side,blue,green,yellow,black);"></div><pre><code>background: -webkit-radial-gradient(60% 55%, closest-side,blue,green,yellow,black);</code></pre><div style="height: 150px;width: 150px;background: -webkit-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black);"></div><pre><code>background: -webkit-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black);</code></pre><div style="height: 150px;width: 150px;background: -webkit-radial-gradient(60% 55%, closest-corner,blue,green,yellow,black);"></div><pre><code>background: -webkit-radial-gradient(60% 55%, closest-corner,blue,green,yellow,black);</code></pre><div style="height: 150px;width: 150px;background: -webkit-radial-gradient(60% 55%, farthest-corner,blue,green,yellow,black);"></div><pre><code>background: -webkit-radial-gradient(60% 55%, farthest-corner,blue,green,yellow,black);</code></pre><p><strong>重复的径向渐变</strong></p><p>repeating-radial-gradient() 函数用于重复径向渐变：</p><div style="height: 150px;width: 200px;background: repeating-radial-gradient(   #EE2C2C, black 20%)"></div><pre><code>#gradl{    height: 150px;    width: 200px;    background: repeating-radial-gradient(#EE2C2C, black 20%);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;CSS3-渐变（Gradients）&quot;&gt;&lt;a href=&quot;#CSS3-渐变（Gradients）&quot; class=&quot;headerlink&quot; title=&quot;CSS3 渐变（Gradients）&quot;&gt;&lt;/a&gt;CSS3 渐变（Gradients）&lt;/h4&gt;&lt;div id=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3弹性盒子</title>
    <link href="http://yoursite.com/2018/12/11/CSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90/"/>
    <id>http://yoursite.com/2018/12/11/CSS3弹性盒子/</id>
    <published>2018-12-11T09:55:59.000Z</published>
    <updated>2018-12-17T07:12:57.597Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS常用命名规范</title>
    <link href="http://yoursite.com/2018/12/10/CSS%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/12/10/CSS常用命名规范/</id>
    <published>2018-12-10T09:16:33.000Z</published>
    <updated>2018-12-17T08:19:01.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="class的命名"><a href="#class的命名" class="headerlink" title="class的命名"></a>class的命名</h4><p>头：header<br>内容：content/container<br>尾：footer<br>导航：nav navigation n.航行；航海<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体佈局宽度：wrapper<br>左右中：left right center<br>登录条：loginbar<br>标志：logo<br>广告：banner<br>页面主体：main<br>热点：hot<br>新闻：news<br>下载：download<br>子导航：subnav<br>菜单：menu<br>子菜单：submenu<br>搜索：search<br>友情链接：friendlink<br>页脚：footer<br>版权：copyright<br>滚动：scroll<br>内容：content<br>标签：tags<br>文章列表：list<br>提示信息：msg–message<br>小技巧：tips<br>栏目标题：title<br>加入：joinus<br>指南：guide<br>服务：service<br>注册：regsiter<br>状态：status<br>投票：vote<br>合作伙伴：partner</p><h4 id="id的命名"><a href="#id的命名" class="headerlink" title="id的命名"></a>id的命名</h4><p><strong>页面结构</strong></p><p>容器: container<br>页头：header<br>内容：content/container<br>页面主体：main<br>页尾：footer<br>导航：nav<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体佈局宽度：wrapper<br>左右中：left right center</p><p><strong>导航</strong></p><p>导航：nav<br>主导航：mainnav<br>子导航：subnav<br>顶导航：topnav<br>边导航：sidebar<br>左导航：leftsidebar<br>右导航：rightsidebar<br>菜单：menu<br>子菜单：submenu<br>标题: title<br>摘要: summary</p><p><strong>功能</strong></p><p>标志：logo<br>广告：banner<br>登陆：login<br>登录条：loginbar<br>注册：register<br>搜索：search<br>功能区：shop<br>标题：title<br>加入：joinus<br>状态：status<br>按钮：btn<br>滚动：scroll<br>标籤页：tab<br>文章列表：list<br>提示信息：msg<br>当前的: current<br>小技巧：tips<br>图标: icon<br>注释：note<br>指南：guild<br>服务：service<br>热点：hot<br>新闻：news<br>下载：download<br>投票：vote<br>合作伙伴：partner<br>友情链接：link<br>版权：copyright</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;class的命名&quot;&gt;&lt;a href=&quot;#class的命名&quot; class=&quot;headerlink&quot; title=&quot;class的命名&quot;&gt;&lt;/a&gt;class的命名&lt;/h4&gt;&lt;p&gt;头：header&lt;br&gt;内容：content/container&lt;br&gt;尾：footer&lt;b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>其他小知识点</title>
    <link href="http://yoursite.com/2018/12/09/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/12/09/其他知识点/</id>
    <published>2018-12-09T09:16:33.000Z</published>
    <updated>2018-12-18T08:48:04.423Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何像JQuery里面一样连续调用-return-this"><a href="#如何像JQuery里面一样连续调用-return-this" class="headerlink" title="如何像JQuery里面一样连续调用 (return this)"></a>如何像JQuery里面一样连续调用 (return this)</h4><pre><code>var deng = {    smoke : function(){        console.log(&apos;Smoking...!!!&apos;);        return this;        //隐式 return undefined    },    drink : function(){        console.log(&apos;drinking...ye!&apos;);        return this;    },    perm : function(){        console.log(&apos;perming...cool!&apos;);        return this;    }}deng.smoke().drink().perm().smoke().drink();</code></pre><h4 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h4><p>指向函数自身引用</p><pre><code>//此时想用递归求阶乘 但是,函数是一个匿名函数var num = (function (n){    if(n ==1){        return 1;    }    return n * arguments.callee(n-1)}(10))</code></pre><h4 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h4><pre><code> function test(){    demo();}function demo(){    console.log(demo.caller);}test();</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;如何像JQuery里面一样连续调用-return-this&quot;&gt;&lt;a href=&quot;#如何像JQuery里面一样连续调用-return-this&quot; class=&quot;headerlink&quot; title=&quot;如何像JQuery里面一样连续调用 (return this)&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2018/11/28/%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/11/28/数组/</id>
    <published>2018-11-28T09:16:33.000Z</published>
    <updated>2018-12-18T10:27:50.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><font color="red">数组</font></h4><p><strong><font color="red">两种构造方法:</font></strong></p><p>1.字面量</p><pre><code>var arr = [1,2,,,,3,4];</code></pre><p> 上面这种数组属于<font color="red">稀松数组</font></p><p>2.构造函数</p><pre><code>var arr = new Array(1,2,3,4);</code></pre><p> JavaScript里的数组是基于对象的  即数组是一种特殊的对象</p><pre><code>var arr = new Array(10);var arr1 = [10];</code></pre><p> 这里arr创建了10个空数组，而arr1创建了1个参数为10的数组</p><h4 id="判断数组类型"><a href="#判断数组类型" class="headerlink" title="判断数组类型"></a><font color="red">判断数组类型</font></h4><p> 给定一个未知对象,判定他是否为数组 在es5中可以使用Array.isArray()函数来判断</p><pre><code>Array.isArray([]);// trueArray.isArray({});// falseArray.isArray(1);// false</code></pre><p>在es5之前,大家可能想到利用typeof操作符来判断,但是无论是数组还是对象,均返回对象</p><pre><code>typeof [];// objecttypeof {};// object</code></pre><p>在es3中isArray()可以使用Object.prototype.toString.call(arr) === ‘[object Array]’代替</p><pre><code>Object.prototype.toString.call([]);// &apos;[object Array]&apos;Object.prototype.toString.call({});// &apos;[object Object]&apos;</code></pre><p><strong><font color="red">数组的添加和删除</font></strong></p><p>• <strong>添加</strong><br>    1.最简单的方法：为新索引赋值<br>    2.使用push()和unshift()方法</p><p>• <strong>删除</strong><br>    1.delete运算符删除数组元素(不会修改数组的length属性)<br>    2.使用pop()和shuift()方法</p><h4 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a><font color="red">数组的常用方法</font></h4><p> • <strong><font color="red">改变原数组: push, pop, shift, unshift, sort, reverse, splice</font></strong></p><p> • <strong><font color="red">不改变原数组: concat, join , split, toString, slice</font></strong></p><h4 id="push-在最后一位添加"><a href="#push-在最后一位添加" class="headerlink" title="push (在最后一位添加)"></a><font color="red">push (在最后一位添加)</font></h4><pre><code>var arr = [1,2];Array.prototype.push = function (){for(var i=0;i&lt;arguments.length;i++){    this[this.length] = arguments[i];}    return this.length;}</code></pre><h4 id="pop-在最后一位剪切"><a href="#pop-在最后一位剪切" class="headerlink" title="pop (在最后一位剪切)"></a><font color="red">pop (在最后一位剪切)</font></h4><h4 id="shift-在最前面剪切"><a href="#shift-在最前面剪切" class="headerlink" title="shift (在最前面剪切)"></a><font color="red">shift (在最前面剪切)</font></h4><h4 id="unshift-在最前面添加"><a href="#unshift-在最前面添加" class="headerlink" title="unshift (在最前面添加)"></a><font color="red">unshift (在最前面添加)</font></h4><h4 id="reverse-反转"><a href="#reverse-反转" class="headerlink" title="reverse (反转)"></a><font color="red">reverse (反转)</font></h4><pre><code>var arr = [1, 2, 3, 4, 5];arr.reverse();// [5, 4, 3, 2, 1]</code></pre><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a><font color="red">splice</font></h4><p><strong>arr.splice(从第几位开始, 截取多少的长度, 在切口处添加新的数据);</strong></p><pre><code>var arr = [1, 1, 2, 2, 3, 3];arr.splice(1, 2);// 删除 arr = [1,2,3,3]  arr.splice(1, 1, 0,0,0);// 替换 arr = [1, 0, 0, 0, 2, 2, 3, 3]arr.splice(3, 0, 4);// 等同于在第三位添加4var arr = [1,2,3,4]arr.splice(-1, 1);//arr = [1,2,3]   -1+lengtharr.splice(-1, 2);//arr = [1,2] </code></pre><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort (排序)"></a><font color="red">sort (排序)</font></h4><pre><code>var arr = [1,3,5,4,10];arr.sort();//按照ascll码排序</code></pre><p><strong>自定义排序:<br>            1.必须写两形参<br>            2.看返回值:<br>                       1)当返回值为负数时,那么前面的数放在前面<br>                       2) 为正数,那么后面的数在前<br>                       3) 为0,不动</strong></p><pre><code>var arr = [3,1,5,10,4];arr.sort(function(a, b){    if(a &gt; b){          return 1;    }else{        return -1;    }});//升序 a &gt; b ; 降序a &lt; bvar arr = [3,1,5,10,4];arr.sort(function(a, b){    return a - b;});// return a - b;升序    // return b - a;降序  </code></pre><p>给一个有序的数组,乱序:</p><pre><code>var arr = [1,2,3,4,5,6,7,8];arr.sort(function(a, b){    return Math.random()-0.5;});</code></pre><p>按照对象年龄大小排序:</p><pre><code>var cheng = {    name : &quot;cheng&quot;,    age : 30,    sex : &quot;male&quot;}var deng = {    name : &quot;deng&quot;,    age : 50,    sex : &quot;male&quot;}var zhang = {    name : &quot;zhang&quot;,    age : 40,    sex : &quot;female&quot;}var arr = [cheng, deng, zhang];arr.sort(function(a, b){    return a.age - b.age;});</code></pre><p>按照字符串长度排序:</p><pre><code>function retBytes(str){    var num = str.length;    for(var i=0;i&lt;str.length;i++){        if(str.charCodeAt(i)&gt;255){            num ++;        }    }    return num;}var  arr = [&apos;a邓&apos;, &apos;bd邓&apos;, &apos;cc老邓&apos;, &apos;ddddd&apos;, &apos;slkhadkhja&apos;];arr.sort(function(a, b){    return retBytes(a) - retBytes(b);});</code></pre><h4 id="concat-拼接-连接"><a href="#concat-拼接-连接" class="headerlink" title="concat (拼接/连接)"></a><font color="red">concat (拼接/连接)</font></h4><pre><code>var arr = [1,2,3];var arr1 = [3,2,1];var arr2 = arr.concat(arr1);// [1,2,3,3,2,1]</code></pre><h4 id="slice"><a href="#slice" class="headerlink" title="slice "></a><font color="red">slice </font></h4><p>从该位开始截取, 截取到该位(不包括)</p><pre><code>var arr = [5,4,3,2,1,6];var newArr = arr.slice(1, 4);// [4, 3, 2]var newArr1 = arr.slice(1);// [4, 3, 2, 1, 6]</code></pre><h4 id="join"><a href="#join" class="headerlink" title="join"></a><font color="red">join</font></h4><p>将数组中所有元素都转化成字符串并连接在一起，返回最后生成的字符串<br>可以选择一个可选的字符串在生成的字符串中来分隔数组的各个元素。<br>如果不指定使用分隔符，默认使用逗号。不修改原数组。</p><pre><code>var arr = [1,2,3];var newArr = arr.join(&quot;-&quot;);//&quot;1-2-3&quot;</code></pre><p>利用join(“”)可以实现大量字符串拼接</p><pre><code>var str = &quot;das&quot;;var str1 = &quot;dqqd&quot;;var str2 = &quot;fvmixk&quot;;var str3 = &quot;qqqmlx&quot;;var str4 = &quot;zmcxol&quot;;var str5 = &quot;qpuh&quot;;var str6 = &quot;lough&quot;;var f = &quot;&quot;;var arr = [str,str1,str2,str3,str4,str5,str6,f];var newArr = arr.join(&quot;&quot;);</code></pre><h4 id="split"><a href="#split" class="headerlink" title="split"></a><font color="red">split</font></h4><p>split()方法是按照给定的字符串将字符串分割成若干块来创建一个数组。</p><pre><code>var arr1 = newArr.split(&quot;-&quot;);//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</code></pre><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a><font color="red">indexOf</font></h4><p>返回某个指定的字符串值在数组中首次出现的位置，从头至尾搜索，没有则返回-1</p><pre><code>var arr = [1, 1, 2, 3, 5, 5];arr.indexOf(1);// 0</code></pre><h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a><font color="red">lastIndexOf</font></h4><p>返回某个指定的字符串值在数组中最后一次出现的位置，从尾至头搜索，没有则返回-1</p><pre><code>arr.lastIndexOf(5);// 5</code></pre><p>同时我们可以在方法中传入两个参数，第一个参数代表需要搜索的值，第二个参数代表从哪一位开始搜索</p><pre><code>arr.indexOf(1,1);// 1</code></pre><p>写indexOf源码</p><pre><code>Array.prototype.myIndexOf = function(){    var startIndex = 0;    var args = arguments;    var len = this.length;    if(args[1]){// 如果有第二个参数         startIndex = args[1];    }    for(var i = startIndex;i &lt; len;i++){        if(this[i] == args[0]){// 参数一            return i;// 返回参数一的索引值        }    }    return -1;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;数组&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;两种构造方法:&lt;/font&gt;&lt;/str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>克隆算法</title>
    <link href="http://yoursite.com/2018/11/27/%E5%85%8B%E9%9A%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/27/克隆算法/</id>
    <published>2018-11-27T09:16:33.000Z</published>
    <updated>2018-12-18T09:43:54.851Z</updated>
    
    <content type="html"><![CDATA[<p>克隆和我们前面所讲的继承有一些区别，克隆是复制出来一个一模一样的目标对象，而克隆又分为浅层克隆和深层克隆。</p><p>• <strong><font color="red">浅层克隆</font></strong></p><p>克隆大致就是我们的源对象里面有什么属性，目标文件就有什么属性，依照这个原理，我们可以写出下面的代码：</p><pre><code>function clone(src, tar) {var tar = tar || {};// 如果没有tar则默认是一个空对象for(var prop in src) {      if(src.hasOwnProperty(prop)){           tar[prop] = src[prop];      } } return tar; }</code></pre><p>下面我们来测试一下:</p><pre><code>var obj = {      name: &apos;scarlett&apos;,      age: 123}var obj2 = {}clone(obj, obj2);console.log(obj2.name);// scarlett</code></pre><p>然后我们改变一下obj这个源对象的name：</p><pre><code>obj.name = &apos;test&apos;console.log(obj2.name);// scarlett</code></pre><p>我们可以发现，克隆出来的目标对象和本来的源对象之间没有关系了<br>但是，当我们有一个属性是引用值（数组或者对象）的时候，按照我们这种克隆方式，只是把这个引用值的指向赋给了新的目标对象，也就是说，我们一旦改变了源对象或者目标对象的引用值属性，另一个也会跟着改变，这一点就是浅层克隆的缺点。</p><p>• <strong><font color="red">深层克隆</font></strong></p><p><strong>思路:<br>    1.遍历对象<br>    2.判断是否是原始值 还是引用值<br>    3.判断引用值类似是数组还是对象<br>    4.建立相应的数组或对象<br>    5.递归</strong></p><pre><code>function clone(origin, target){    var target = target || {},//防止用户不传target参数         toStr = Object.prototype.toString,         arrStr = &quot;[object Array]&quot;;    for(var prop in origin){        if(origin.hasOwnProperty(prop)){            if( origin[prop] !== &quot;null&quot; &amp;&amp; typeof(origin[prop]) == &apos;object&apos;){                if(toStr.call(origin[prop]) == arrStr){                    target[prop] = [];                }else{                    target[prop] = {};                }                clone(origin[prop], target[prop]);            }else{                target[prop] = origin[prop];            }        }    }}</code></pre><p>现在我们来测试一下：</p><pre><code>var parent = {      name : ‘ScarLet’,      age : 123,      sex : ‘male’,      height : 190,      money: [1,2,3,4,5]}var child = {};deepCopy(parent,child);console.log(child.money);//1 2 3 4 5parent.money.push(10);console.log(child.money);// 1 2 3 4 5</code></pre><p>这个时候目标对象和源对象的引用值之间就没有了关系，自己都是独立值，可以进行修改了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;克隆和我们前面所讲的继承有一些区别，克隆是复制出来一个一模一样的目标对象，而克隆又分为浅层克隆和深层克隆。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;&lt;font color=&quot;red&quot;&gt;浅层克隆&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;克隆大致就是我们的源对象里面有什么属性，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>严格模式与try-catch</title>
    <link href="http://yoursite.com/2018/11/26/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8Etry-catch/"/>
    <id>http://yoursite.com/2018/11/26/严格模式与try-catch/</id>
    <published>2018-11-26T09:16:33.000Z</published>
    <updated>2018-12-18T09:32:43.278Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ES5-0严格模式"><a href="#ES5-0严格模式" class="headerlink" title="ES5.0严格模式"></a><font color="red">ES5.0严格模式</font></h4><p>• 浏览器 基于的es3.0的 + es5.0的新增方法 使用的<br>• es3.0 和 es5.0产生冲突的部分<br>• es5.0严格模式: 那么es3.0和es5.0产生冲突的部分就是用es5.0，否则会用es3.0</p><p><strong>es5.0严格模式的启动</strong>: 必须写在页面逻辑的最顶端 或 方法里面最顶端(局部)</p><pre><code>&quot;use strict&quot;;局部使用function test(){    &quot;use strict&quot;;    console.log(arguments.callee);}test();</code></pre><p><strong>严格模式下: • with, arguments.callee, caller(不能使用)<br>             • 变量赋值必须声明,局部this必须赋值<br>             • 拒绝重复属性和参数<br>             • es3.0 都不能使用eval();</strong></p><pre><code>如:function test(name, name){    &quot;use strict&quot;;    console.log(name);}test(1,2);var obj = {    name : &apos;123&apos;,    name : &apos;234&apos;}</code></pre><h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a><font color="red">try…catch</font></h4><p><strong>三段式:</strong></p><pre><code>try{}catch(e){    }finally{    }</code></pre><p><strong>error对象 ——&gt; error.massage error.name<br>Error.name的六种值对应的信息</strong></p><p>  1.EvalError: eval()的使用与定义不一致<br>  2.RangeError: 数值越界<br>  3.ReferenceError: 非法或不能识别的引用数值<br>  4.SyntaxError: 发生语法解析错误<br>  5.TypeError: 操作数类型错误<br>  6.URIError: URI处理函数使用不当</p><pre><code>console.log(b);// ReferenceError    没定义就使用test();        // ReferenceError var str = abcd;// ReferenceErrorfunction demo(){      :}//SyntaxError       语法解析错误//在try里面的发生错误,不会执行错误后的try里面的代码try{    console.log(&apos;a&apos;);    console.log(b);    console.log(&apos;c&apos;);}catch(e){    console.log(e.massage+&quot; &quot;+e.name);//出错走这里}    console.log(&apos;d&apos;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ES5-0严格模式&quot;&gt;&lt;a href=&quot;#ES5-0严格模式&quot; class=&quot;headerlink&quot; title=&quot;ES5.0严格模式&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;ES5.0严格模式&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;• 浏览器 基于的es3.0的 +
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>this</title>
    <link href="http://yoursite.com/2018/11/25/this/"/>
    <id>http://yoursite.com/2018/11/25/this/</id>
    <published>2018-11-25T09:16:33.000Z</published>
    <updated>2018-12-18T09:41:19.743Z</updated>
    
    <content type="html"><![CDATA[<h4 id="this"><a href="#this" class="headerlink" title="this"></a><font color="red">this</font></h4><p><strong>  1.函数预编译过程 this ——&gt;window<br>    2.全局作用域里   this ——&gt;window<br>    3.call/apply可以改变函数运行时this指向<br>    4.obj.func();    func()里面的this指向obj </strong>    </p><p><strong>总结: 四种this绑定的权重</strong></p><p><strong>  1,默认绑定(空函数执行,函数单纯执行,this指向window) 默认权重<br>    2,隐式帮定(谁调用this指向谁) 第三权重<br>    3,显式绑定 (call apply bind) 第二高权重<br>    4,new 绑定this 权重是最高的</strong></p><p><strong>升级知识：ES6箭头函数中的this如何邦定？<br>  1,箭头函数没有this 没有arguments surper(class)；<br>  2,箭头函数不能new ,不当成构造函数来 没有prototye；<br>  3,可以表示数据流向 方便JavaScript引擎优化扫码；</strong></p><p>例1</p><pre><code>var name = &quot;222&quot;;var a = {    name : &quot;111&quot;,    say : function(){        console.log(this.name);    }}var fun = a.say;fun();//预编译this指向windowa.say();//a执行this指向对象avar b = {    name : &quot;333&quot;,    say : function(fun){        fun();//预编译this指向window    }}b.say(a.say);b.say = a.say;b.say();//b执行this指向对象b</code></pre><p>例2</p><pre><code>var foo = 132;function print(){    this.foo = 234;    console.log(foo);}print();</code></pre><p>例3</p><pre><code>var foo = 132;function print(){    //var this = Object.create(print.prototype)    this.foo = 234;    console.log(foo);}new print();</code></pre><p>例4</p><pre><code>var a = 5;function test(){    a = 0;    console.log(a);    console.log(this.a);    var a;    console.log(a);}test();</code></pre><p>例5</p><pre><code> var a = 5;function test(){    a = 0;    console.log(a);    console.log(this.a);    var a;    console.log(a);}new test();</code></pre><p>例6</p><pre><code>var bar = {    a : &quot;002&quot;}function print(){    bar.a = &apos;a&apos;;    Object.prototype.b = &apos;b&apos;;    return function inner(){        console.log(bar.a);        console.log(bar.b);    }}print()();</code></pre><h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a><font color="red">call/apply</font></h4><p>call/apply的第一个参数会<font color="red">改变this的指向</font><br>• call 需要把实参按照形参的个数传进去<br>• apply 需要传一个arguments(数组)<br>其实方法的执行test()，实际上就是隐式转换成test.call();</p><pre><code>function Person(name, age){     this.name = name;     this.age = age;}var person = new Person(&apos;deng&apos;, 100);var obj = {};Person.call(obj, &apos;cheng&apos;, 300);console.log(obj.name);// &apos;cheng&apos;</code></pre><p>例1</p><pre><code>function Person(name, age, sex){    this.name = name;    this.age = age;    this.sex = sex;}         function Student(name, age, sex, tel, grade){    //this指向Student  本来是没有name/age/sex属性 用Person的方法实现自己的功能       //var this = {name : &quot;&quot;, age : &quot;&quot;, sex : &quot;&quot;}    Person.call(this, name, age, sex);    this.tel = tel;    this.grade = grade;}var student = new Student(&apos;sunny&apos;, 123, &apos;male&apos;, 139, 2017);</code></pre><p>例2</p><pre><code>function Wheel(wheelSize, style){    this.style = style;    this.wheelSize = wheelSize;}function Sit(c, sitColor){    this.c = c;    this.sitColor = sitColor;}function Model(height, width, len){    this.height = height;    this.width = width;    this.len = len;}function Car(wheelSize, style, c, sitColor, height, width, len){    Wheel.call(this, wheelSize, style);    Sit.call(this, c, sitColor);    Model.call(this, height, width, len);}var car = new Car(100, &quot;花里胡哨的&quot;, &quot;真皮&quot;, &quot;red&quot;, 1800, 1900, 4900);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;this&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;  1.函数预编译过程 this ——&amp;gt;window
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对象枚举及访问属性的第二种方法</title>
    <link href="http://yoursite.com/2018/11/24/%E5%AF%B9%E8%B1%A1%E6%9E%9A%E4%B8%BE%E5%8F%8A%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/24/对象枚举及访问属性的第二种方法/</id>
    <published>2018-11-24T09:16:33.000Z</published>
    <updated>2018-12-18T08:49:49.176Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对象的枚举"><a href="#对象的枚举" class="headerlink" title="对象的枚举"></a><font color="red">对象的枚举</font></h4><p>在介绍对象的枚举方法之前，我们要理解一个概念。</p><p>查看对象属性我们知道可以用obj.name这样的点操作符来查看，但是我们还有一种其他的方式：</p><p><strong><font color="red">obj[字符串]</font></strong></p><p>这种方法类似数组的查看，但其实事实是数组模仿了对象的查看方式。<br>这种方法是在系统底层里面的查看对象属性的写法，我们常用的点操作符obj.name在系统底层其实也隐式转换成了obj[‘name’]这种形式。</p><p><strong>例</strong></p><pre><code>var deng = {    wife1 : {name : &quot;xiaoliu&quot;},    wife2 : {name : &quot;xiaozhang&quot;},    wife3 : {name : &quot;xiaomeng&quot;},    wife4 : {name : &quot;xiaowang&quot;},    sayWife : function (num){        return this[&apos;wife&apos;+num]    }}// 我们调用sayWife的时候传入一个对应的数字就可以得到返回对应的名字</code></pre><p><strong><font color="red">for-in操作符</font></strong></p><p>我们知道要枚举一个数组的所有元素，只要用一个for循环从头到尾遍历一遍就可以了。</p><p>但是对象并不能用for循环来遍历属性，所以这里我们就要使用for-in操作了。</p><pre><code>var obj = {    name : &apos;13&apos;,    age : 123,    sex : &quot;male&quot;,    height : 180,    weight : 75}for(var prop in obj){    //obj是要遍历的对象  prop变量名写什么都行    //console.log(obj.prop);    结果全是undefined     //因为 obj.prop ——&gt;obj[&apos;prop&apos;] 而prop是个变量所以 改为下面访问属性方式    console.log(obj[prop]);}</code></pre><p>下面我们来介绍三种操作符：</p><p>1.<strong><font color="red">hasOwnProperty</font></strong></p><p>这个操作符的作用是查看当前这个属性是不是对象自身的属性，在原型链上的属性则会被过滤掉。如果是自身的，就返回true，否则返回false。    </p><pre><code>function Person(){    this.name = &apos;scarlett&apos;}Person.prototype = {    age : 10}var operson = new Person();for(var prop in operson){    if(operson.hasOwnProperty(prop)){        console.log(operson[prop]);    }}</code></pre><p>这样，我们的for-in循环就会只打印自身的属性而不会去打印原型上的lastName属性。</p><p>2.<strong><font color="red">in操作符</font></strong></p><p>这个操作符的作用是查看一个属性是不是在这个对象或者它的原型里面。</p><pre><code>&apos;name&apos; in operson;// true&apos;age&apos; in operson;// true&apos;sex&apos; in operson;// false</code></pre><p>3.<strong><font color="red">instanceof操作符</font></strong></p><p>看A对象的原型链上 有没有 B的原型</p><pre><code>function Person(){}var person = new Person();person instanceof Person;// trueperson instanceof Object;// true</code></pre><h4 id="判断一个变量是数组还是对象"><a href="#判断一个变量是数组还是对象" class="headerlink" title="判断一个变量是数组还是对象"></a>判断一个变量是数组还是对象</h4><p><strong><font color="red">三种方法:</font></strong></p><p><strong>方法1.</strong></p><pre><code>数组的 [].constructor  对象的 var obj={}, obj.constructor</code></pre><p><strong>方法2.</strong></p><pre><code>[] instanceof Array   返回true   obj instanceof Array  返回false</code></pre><p><strong>方法3.</strong></p><pre><code>Object.prototype.toString.call([]);Object.prototype.toString.call({});</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;对象的枚举&quot;&gt;&lt;a href=&quot;#对象的枚举&quot; class=&quot;headerlink&quot; title=&quot;对象的枚举&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;对象的枚举&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;在介绍对象的枚举方法之前，我们要理解一个概念。&lt;/p&gt;
&lt;p&gt;查看
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="http://yoursite.com/2018/11/23/%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2018/11/23/继承/</id>
    <published>2018-11-23T09:16:33.000Z</published>
    <updated>2018-12-18T08:08:51.445Z</updated>
    
    <content type="html"><![CDATA[<p>1.<strong>传统形式 ——原型链 (过多的继承了没用的属性)</strong></p><p>2.<strong>借用构造函数 (不能继承借用构造函数的原型,每次构造函数都要多走一个函数)</strong></p><p>3.<strong>共享原型 (不能随便改动自己的原型)</strong></p><p>4.<strong>圣杯模式 (以上三种模式都不用)</strong></p><h4 id="模式一"><a href="#模式一" class="headerlink" title="模式一"></a><font color="red">模式一</font></h4><pre><code>Grand.prototype.lastName = &quot;Deng&quot;;function Grand(){}var grand = new Grand();Father.prototype = grand;function Father(){     this.name = &quot;hehe&quot;;}var father = new Father();Son.prototype = father;function Son(){}var son = new Son();</code></pre><h4 id="模式二"><a href="#模式二" class="headerlink" title="模式二"></a><font color="red">模式二</font></h4><pre><code>function Person(name, age, sex){    this.name = name;    this.age = age;    this.sex = sex;}function Student(name, age, sex, grade){    Person.call(this, name, age, sex);    this.grade = grade;}var student = new Student();</code></pre><h4 id="模式三"><a href="#模式三" class="headerlink" title="模式三"></a><font color="red">模式三</font></h4><pre><code>Father.prototype.lastName = &quot;Deng&quot;;function Father(){ }function Son(){}Son.prototype = Father.prototype; var son = new Son();//或抽象出一个继承方法    但是如果son想修改原型father也会发生改变Father.prototype.lastName = &quot;Deng&quot;;function Father(){ }function Son(){}function inherit(Target, Origin){    Target.prototype = Origin.prototype;}inherit(Son, Father);var son = new Son();var father = new Father();</code></pre><h4 id="模式四"><a href="#模式四" class="headerlink" title="模式四"></a><font color="red">模式四</font></h4><pre><code>function inherit(Target, Origin){    function F(){};    F.prototype = Origin.prototype;    Target.prototype = new F();    Target.prototype.constuctor = Target;//将构造器归位    Target.prototype.uber = Origin.prototype;//继承自 找到自己的超类(uber==super)}Father.prototype.lastName = &quot;Deng&quot;;function Father(){ }function Son(){}inherit(Son, Father);var son = new Son();var father = new Father();Son.prototype.sex = &quot;male&quot;;//此时修改son的原型上的属性不会影响father</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;strong&gt;传统形式 ——原型链 (过多的继承了没用的属性)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;借用构造函数 (不能继承借用构造函数的原型,每次构造函数都要多走一个函数)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;共享原型 (不能随便改动
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数作用域与闭包</title>
    <link href="http://yoursite.com/2018/11/22/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/11/22/函数作用域与闭包/</id>
    <published>2018-11-22T09:16:33.000Z</published>
    <updated>2018-12-18T08:04:24.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a><font color="red">函数部分</font></h2><p>我们的函数声明有两种方式：</p><p>1.<font color="red">var demo = function () {} 函数表达式</font></p><pre><code>注意: 下面这些也属于函数表达式         = function(){}            ! function(){}       + function(){}       - function(){}</code></pre><p>2.<font color="red">function demo () {} 函数声明</font></p><p>3.var demo = function xxx() {} 命名函数表达式</p><p>• 每一个函数里面都有一个类似数组的<font color="red">类数组属性arguments</font>，这个属性里面存的就是<font color="red">实参</font>。</p><p>arguments[0]就可以查看我们传递的第一个实参了。</p><p>函数有一个<font color="red">length属性</font>，这个length储存的是<font color="red">形参的数量</font>。</p><p>• 每一个函数都会有一个return，如果不写的话函数会自动加上一个return;</p><p>return的功能有两个：</p><p>1.返回这个函数的<font color="red">执行结果</font>。</p><p>2.<font color="red">终止函数的执行</font>。</p><pre><code>function test(a, b){    console.log(a + b);    return ;    console.log(&apos;hello&apos;);}test(1, 2);// 3 没有打印hello</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><font color="red">作用域</font></h2><p>定义：变量（变量作用域又称为上下文）和函数生效（能被访问）的区域。</p><p><font color="red"><strong>javascript的函数，是可以产生作用域的！！</strong></font><br>es5中的作用域大概只有全局作用域和函数作用域两种，es6中新添加了块级作用域。</p><pre><code>var demo = 123;// 全局变量function test(){    var demo = 234;// 局部变量    console.log(demo);    var demo1 = &apos;hello&apos;;}test();// 234 就近打印局部变量，没有局部变量的时候才会打印全局的。console.log(demo1); // 报错 我们的全局作用域无法访问函数的局部作用域</code></pre><p>• 有一点要注意的是，如果在函数作用域里面声明变量<font color="red">没有用var的话</font>，那么就声明了一个全局变量。<br>• 同时，两个不同作用域（除了全局作用域）之间是不能互相访问的。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a><font color="red">作用域链</font></h2><p>既然函数存在函数作用域，函数又可以嵌套，那么作用域之间自然就会产生嵌套关系，这个时候就产生了作用域链。<br>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境<font color="red">有权</font>访问的变量和函数的<font color="red">有序</font>访问。作用域第一个对象始终是当前执行代码所在环境的变量对象。</p><pre><code>function demo() {    var demo_a = 1;    function test() {        var demo_a = 2;        console.log(demo_a);    }    test();}demo();</code></pre><p>• 在这个例子中，demo运行的时候，首先创建了一个demo的作用域，但是window本身还有一个全局作用域，这就让demo产生了一个作用域链。本着对执行环境的有权和有序访问，每个函数的自身的作用域总是在作用域链的最顶层，下一层是这个函数的父级函数的作用域，再下面是父级的父级的作用域，直到全局作用域。</p><p>• 因此这个例子中的test函数执行时候打印的demo_a是它本身的作用域中的demo_a，而不是demo函数作用域下的demo_a，如果test函数作用域中没有demo_a这个变量的话，系统才会沿着作用域链向下找到demo作用域中的demo_a变量。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><font color="red">闭包</font></h2><p>闭包是一个非常非常重要的知识点，我在网上看到过许多的定义，但是都有点繁琐，这里的知识点是我简单化的总结的。</p><p>什么是闭包？</p><p>我的理解是，<font color="red"><strong>闭包就是能够读取其他函数内部变量的函数</strong></font>。</p><p>我们前面提到过，不同作用域之间不能够互相访问，但是我们如果在一个<font color="red">函数内部再定义一个函数</font>，并且这个<font color="red">内部函数与外部函数的变量有关联</font>，那么我们就可以通过<font color="red">返回这个内部的函数</font>，然后<font color="red">来访问外部函数里面的变量</font>。</p><p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><pre><code>function a(){    var demo1 = 123;    add = function(){        demo1++;    }     return function(){        console.log(demo1);    };}var demo = a();demo();// 123add();demo();// 124</code></pre><p>当函数执行完之后，函数的执行上下文就会被销毁，自然我们就无法访问里面的变量了，但是我们这个函数返回了一个<font color="red">依赖于这个函数的新函数，也就是说这个没有被销毁的新函数的作用域链中还存在着对原本函数的作用域的引用</font>，就导致我们原本的函数的上下文不会被销毁，我们<font color="red">称返回的这个新函数是原本函数的闭包函数</font>。</p><p>在上面的例子中，a函数内部有一个全局的函数add和一个局部变量demo1，我们这个把返回函数给了一个全局变量demo进入到了内存中，但是由于这个返回的新函数依赖于本来的a函数，这就导致本来的a函数的上下文不会被销毁。</p><p>这里我们的打印函数一共运行了两次，都能打印出来值，说明a函数的demo1变量在函数执行完之后并没有被销毁而是存到了内存中。</p><p>其次，add的值是一个匿名函数，而这个匿名函数本身也是一个闭包，所以add相当于是一个setter叠加器，可以在函数外部对函数内部的局部变量进行操作。</p><p><strong><font color="red">使用闭包的注意点</font></strong></p><p>1.由于闭包会使得函数中的变量都被保存在内存中，<font color="red">内存消耗很大</font>，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致<font color="red">内存泄露</font>。</p><p>解决方法是，<font color="red">在退出函数之前，将不使用的局部变量全部删除</font>。</p><p>2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把<font color="red">父函数当作对象</font>使用，把<font color="red">闭包当作它的公用方法</font>，把<font color="red">内部变量当作它的私有属性</font>，这时一定要小心，<strong><font color="red">不要随便改变父函数内部变量的值</font></strong>。</p><p><strong><font color="red">闭包的作用</font></strong></p><p><strong>1.实现公有变量</strong></p><pre><code>function add(){    var count = 0;    function demo(){        count ++;        console.log(count);    }    return demo;}var counter = add();counter();counter();counter();counter();</code></pre><p><strong>2.可以做缓存</strong></p><pre><code> function test(){    var num = 100;    function a(){        num ++;        console.log(num);    }       function b(){        num --;        console.log(num);    }    return [a, b];}var myArr = test();myArr[0]();myArr[1]();</code></pre><p><strong>3.可以实现封装，属性私有化</strong></p><pre><code>function Deng(name, wife){     var prepareWife = &quot;xiaozhang&quot;    this.name = name;    this.wife = wife;    this.divorce = function (){        this.wife = prepareWife;    }    this.changePrepareWife = function(target){        prepareWife = target;    }    this.sayPrepareWife = function(){        console.log(prepareWife);    }}var deng = new Deng(&apos;deng&apos;, &apos;xiaoliu&apos;)//里面三个函数和Deng这个函数都形成了闭包,只能通过函数去修改prepareWife属性</code></pre><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a><font color="red">立即执行函数</font></h2><p>立即执行函数是解闭包的一个重要方法。但是注意<font color="red">闭包是没有办法解除</font>的，我们只能通过另一个新闭包来消除上一个闭包的影响。</p><p><strong>定义：立即执行函数不需要被定义，直接执行，执行完毕之后直接释放。</strong></p><p>立即执行函数的写法：</p><p><strong>1.(function (a) {})(num);</strong></p><p><strong>2.(function (a) {} (num))</strong>   W3C建议第二种</p><p>传递的参数是a，a的实参值是num，num是我们在外面定义的变量。</p><p><strong>例</strong></p><pre><code>(function (a,b,c){    var d = a+b+c;    return d;}(1,2,3));// 打印6</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数部分&quot;&gt;&lt;a href=&quot;#函数部分&quot; class=&quot;headerlink&quot; title=&quot;函数部分&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;函数部分&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;我们的函数声明有两种方式：&lt;/p&gt;
&lt;p&gt;1.&lt;font color=&quot;r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>原型</title>
    <link href="http://yoursite.com/2018/11/21/%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/11/21/原型/</id>
    <published>2018-11-21T09:16:33.000Z</published>
    <updated>2018-12-18T06:23:06.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a><font color="red">原型</font></h2><p>1.<strong><font color="red">定义</font></strong>:原型是function对象的一个<font color="red">属性</font>，它定义了构造函数制造出的对象的<font color="red">公共祖先</font>。<br>通过该构造函数产生的对象，可以<font color="red">继承该原型的属性和方法</font>。<strong><font color="red">原型也是对象</font></strong><br>2.利用原型特点和概念，可以提取共有属性<br>3.对象如何查看原型–&gt;隐式属性<strong>proto</strong><br>4.对象如何查看对象的构造函数–&gt;constructor</p><pre><code>//Person.prototype      -- 原型//Person.prototype = {}     是祖先</code></pre><p>1.<font color="red">增</font></p><pre><code>Person.prototype.name = &quot;hehe&quot;;function Person() {}var person = new Person();console.log(person.name);// &quot;hehe&quot;</code></pre><p>2.<font color="red">改</font></p><pre><code>Person.prototype.name = &quot;haha&quot;;console.log(person.name);// &quot;haha&quot;</code></pre><p>3.<font color="red">删</font></p><pre><code>Person.prototype.name = &quot;hehe&quot;;function Person() {}var person = new Person();delete Person.prototype.name;console.log(person.name);// undefined</code></pre><p>我们可以在prototype上面添加属性和方法，每一个构造出来的对象都可以继承这些属性和方法。</p><p>虽然每一个对象都是独立的，但是他们都有共同的祖先，当我们访问这个对象的属性的时候，<font color="red">如果它没有这个属性，就会向上找到它的原型，然后在原型上访问这个属性</font>。</p><p><strong>例1.</strong>提取共有属性  </p><pre><code>Car.prototype.height = 1400;Car.prototype.lang = 4900;Car.prototype.carName = &quot;BMW&quot;;function Car(color, owner){    this.color = color;    this.owner = owner;}var car = new Car(&apos;red&apos;, &apos;prof.ji&apos;);var car1 = new Car(&apos;blue&apos;, &apos;abc&apos;);</code></pre><p><strong>例2.</strong></p><pre><code> Car.prototype = {    height : 1400,    lang : 4900,    carName : &quot;BMW&quot;}function Car(){}var car = new Car();</code></pre><p><strong><font color="red">对象如何查看原型</font></strong></p><p>前面我们提到了构造函数可以通过.prototype的方法来查看构造函数的原型，那么我们怎么查看对象的原型呢？<br>我们前面提到过用构造函数构造对象的时候，会隐式创建一个this对象，这个this对象里面有一个默认的属性叫做<font color="red">proto</font>属性，这个属性的值就是指向的这个对象的原型。</p><pre><code>var this = {    // xxx    __proto: Person.prototype;}</code></pre><p>注意:Person对象的原型<font color="red">未必一定</font>是Person.prototype 可以修改、<font color="red">prototype是函数的属性，proto是对象的属性</font>。</p><p>当查找的属性是自身没有的属性的时候，就会先查找proto这个属性，然后这个属性指向了原型，所以就到原型上面继续查找属性了。</p><p><strong><font color="red">对象如何查看构造自身的构造函数</font></strong></p><p>在prototype里面，有一个隐式的属性叫做<font color="red">constructor</font>，这个属性记录的就是<font color="red">对象的构造器</font>，里面存的就是构造函数。</p><pre><code>Person.prototype.name = &quot;hehe&quot;;function Person() {}var person = new Person();console.log(person.constructor);// Person();</code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><font color="red">原型链</font></h2><p>有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，这样的原型上还有原型的结构就构成了原型链。</p><pre><code>Grand.prototype.lastName = &quot;Deng&quot;;function Grand(){}var grand = new Grand();Father.prototype = grand;function Father(){     this.name = &quot;xuming&quot;;    this.fortune = {        card1 : &apos;visa&apos;    };    this.num = 100;}var father = new Father();Son.prototype = father;function Son(){    this.hobbit = &quot;smoke&quot;;}var son = new Son();</code></pre><p>son可以访问到father以及grand的属性 甚至可以访问到Object.prototype的所有属性<br>调用引用值修改(仅限引用值)<br>其实，<font color="red">绝大部分的对象最终都会继承自<strong>Object.prototype</strong>这个对象</font>。</p><p><font color="red">我们没有规定原型的对象，它们的原型就是<strong>Object.prototype</strong></font>。</p><pre><code>son.fortune.card2 = &quot;master&quot;;son.num++console.log(son.num);// 101console.log(father.num);// 100</code></pre><p>但是<font color="red">并不是所有的对象都有原型</font>。</p><p>我们上一篇提到过第三种构造对象的方法，使用<font color="red">Object.create</font>方法。</p><p>Object.create()方法需要写一个参数，这个参数就是我们这个对象的<font color="red">原型</font>。如果我们想要构造和var obj = {};一样的空对象，那么就需要写：</p><pre><code>var obj = Object.create(Object.prototype);</code></pre><p>但是，当我们写<font color="red">参数为null</font>的时候，我们就构造出来了一个<font color="red">没有原型的对象</font>。</p><pre><code>var obj = Object.create(null);console.log(obj.proto);// undefined</code></pre><p><font color="red">undefined null也都没有原型</font>。它们之所以能打印出来，是因为不调用任何方法的，直接打印出来。</p><h4 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a><font color="red">更多例子</font></h4><p><strong>例1</strong></p><pre><code>Person.prototype.name = &quot;sunny&quot;;function Person(){}var person = new Person();Person.prototype.name = &quot;cherry&quot;;//此处只是改变原对象里面的值 即Person.prototype = {name : &apos;xxx&apos;}console.log(person.name);</code></pre><p><strong>例2</strong></p><pre><code>Person.prototype.name = &quot;sunny&quot;;function Person(){}var person = new Person();Person.prototype = {    // 新引用    name : &quot;cherry&quot;}console.log(person.name);//person.prototype的引用指向并没有发生改变//解释: Person.prototype = {name : &apos;a&apos;};//      __proto__ = Person.prototype;//      Person.prototype = {name : &apos;b&apos;};</code></pre><p><strong>例3</strong></p><pre><code>Person.prototype.name = &quot;sunny&quot;;function Person(){}Person.prototype = {       name : &quot;cherry&quot;}var person = new Person();console.log(person.name);//person.prototype的引用指向了新的Person.prototype</code></pre><p><strong>例4</strong></p><pre><code>Person.prototype = {    name : &apos;a&apos;,    sayName : function(){        console.log(this.name);    }}function Person(){    this.name = &apos;b&apos;;}var person = new Person();//a.sayName()   sayName里面的this指向是，谁调用的这个方法，this就是指向谁//person.sayName();// b//person.prototype.sayName();// a</code></pre><p>方法的重写:将原型链上的toString方法重写</p><pre><code>Person.prototype = {    toString : function(){        return &quot;hehe&quot;;    }}function Person(){}var person = new Person();person.toString();// &quot;hehe&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;原型&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;1.&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;定义&lt;/font&gt;&lt;/strong
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对象与构造函数与包装类</title>
    <link href="http://yoursite.com/2018/11/20/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/11/20/对象与构造函数与包装类/</id>
    <published>2018-11-20T09:16:33.000Z</published>
    <updated>2018-12-18T08:53:35.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象创建方法"><a href="#对象创建方法" class="headerlink" title="对象创建方法"></a><font color="red">对象创建方法</font></h2><p>对象的创建方法有三种：</p><ol><li><p><strong><font color="red">对象字面量</font></strong></p><pre><code>var obj = {}</code></pre></li></ol><p>这样的方式就叫做字面量，也是我们<font color="red">创建对象最简单最常用</font>的方法。</p><p>对象里面有属性，属性之间用逗号分隔，每一条属性都有属性名和属性值，属性名和属性值之间用分号分隔。</p><ol start="2"><li><strong><font color="red">构造函数</font></strong></li></ol><p>构造函数也分两种：<font color="red">系统自带的构造函数</font>和我们<font color="red">自定义的构造函数</font>。</p><p>• <font color="red">系统自带的构造函数</font></p><p>创建对象的构造函数是Object()。</p><pre><code>var obj = new Object();</code></pre><p>它的作用和var obj = {};的作用是一样的。</p><p>系统自带的构造函数还有很多，比如Number()、String()、Boolean()、Array()这些都是构造函数。</p><p>• <font color="red">自定义构造函数</font></p><p>自定义的构造函数是我们平时<font color="red">最常用的一种构造函数</font>。</p><p>构造函数也是正常的函数，我们为了区分它和别的正常函数，把构造函数的首字母大写。</p><pre><code>function Persion(){}</code></pre><p>有了构造函数之后，我们就可以用new操作符来创建对象了。</p><pre><code>var oPerson = new Person();typeof oPerson;// object</code></pre><p>这样我们也创建了一个对象oPerson，不过现在这个对象是空对象，因为我们的构造函数什么都没有写，我们也没有给这个对象添加任何属性。</p><p>另外，用new操作符创建出来的对象，尽管都是使用的同一个构造函数，但是之间是没有关联的。</p><pre><code>var person1 = new Person();var person2 = new Person();person1.name = &apos;111&apos;;console.log(person2.name);// undefined</code></pre><p>我们可以在构造函数里面写一些对象天生就有的默认属性。</p><pre><code>function Person() {    this.name = &apos;scarlett&apos;,    this.age = 17}var person = new Person();person.name;// scarlett</code></pre><p>当然构造函数既然是函数，那么就可以传参数。</p><pre><code>function Person(name, age) {    this.name = name,    this.age = age}var person = new Person(&apos;scarlett&apos;, 18);person.age;// 18</code></pre><p>创建对象的时候，<font color="red">只有new才会有this</font>。</p><p>这里有一个重点，<font color="red">为什么我们通过new操作符可以创建互相独立的对象呢</font>？</p><p>其实，当我们用new操作符的时候，这个new在我们的构造函数里面隐式创建了一个this对象，并且最后返回了这个this对象，这也就是为什么我们通过new可以最后创建一个对象的原因了。</p><pre><code>function Person(name) {    // var this = {};    this.name = name;    // return this;}</code></pre><p>如果我们在构造函数首行手动创建一个对象，比如that对象，然后最后返回了that，那么里面的this就没有用了，我们要为属性赋值就要用that了。</p><pre><code>function person(name) {       var that = {            name : &apos;scarlett&apos;       };       that.name = name;       return that;}var person = new Person(&apos;demo&apos;);person.name;// demo</code></pre><font color="red">重点：如果我们最后返回的对象，那么this就失效，但是如果最后显示返回的是原始值，那么this还是有效的。</font><pre><code>function person(name) {       var that = {};       that.name = &apos;that&apos;;       this.name = &apos;this&apos;;       return 123;}var person = new Person();person.name;// this</code></pre><ol start="3"><li><strong><font color="red">Object.create(原型)</font></strong></li></ol><p>后面原型里面在具体说明</p><h2 id="属性的增删改查"><a href="#属性的增删改查" class="headerlink" title="属性的增删改查"></a><font color="red">属性的增删改查</font></h2><p>1.<strong>增</strong></p><pre><code>var obj = {};obj.name = &apos;scarlett&apos;;obj.name;// scarlett</code></pre><p>我们可以通过对象名+点+属性名的方法来给对象添加新的属性并且赋值。</p><p>这个时候如果我们调用obj.age属性的话，这个属性并不存在，但是obj这个对象是存在的，因此浏览器不会报错，只会打印undefined。</p><p>2.<strong>改</strong></p><p>修改的操作和增加的操作其实是一样的，只要调用相同的属性名然后赋一个新的值就可以了。</p><pre><code>var obj = {    name : &apos;scarlett&apos;};obj.name = &apos;demo&apos;;obj.name;// demo</code></pre><p>3.<strong>查</strong></p><pre><code>obj.name = &apos;demo&apos;;console.log(obj.name);// demo</code></pre><p>4.<strong>删</strong></p><p>删除属性的操作我们需要借助<font color="red">delete</font>操作符，这个操作符的作用就是来删除属性的。</p><pre><code>var obj = {    name : &apos;scarlett&apos;}obj.name;// scarlettdelete obj.name;obj.name;// undefined</code></pre><h2 id="内置对象和包装类型"><a href="#内置对象和包装类型" class="headerlink" title="内置对象和包装类型"></a><font color="red">内置对象和包装类型</font></h2><p><strong><font color="red">内置对象</font></strong></p><p><strong>内置对象</strong>:就是ES标准中规定的浏览器厂商已经实现的API都叫做内置对象。一共11个</p><p><strong><font color="red">String Number Boolean Array Date Math RegExp Error  Function Object Global全局(Window)</font></strong></p><p>这十一个对象都干了两件事,第一是装数据的,第二为了简化你的操作,提供了很多现成的API让你去操作数据</p><p><strong><font color="red">包装类型</font></strong></p><p><strong>包装类型</strong>:专门封装原始类型的值,并提供操作值得API的对象.</p><p>包装类型的值做了两件事,第一件事:封装一个值,然后还提供了对这个值操作的API.</p><p>如何使用:他都是自动创建,自动销毁</p><p>什么时候创建:在试图用原始类型的值,调用函数时,会自动创建对应类型的包装类型对象.调用完函数后自动释放</p><pre><code>var str = ‘abcd’;// var str1 = String(‘abcd’);str.length = 2; // str1.length = 2;//销毁str1console.log(str); // abcd 长度还是4var n = 123.456;n.toFixed(2);// &quot;123.46&quot; 内部其实是 new Number(n).toFixed(2);&quot;张&quot;.charCodeAt();// 24352 内部其实发生了 new String(&quot;张&quot;).charCodeAt();// 为什么要有包装类型:因为原始类型的值本身不能有任何属性和函数,放不下var str = &quot;abc&quot;;str += 1;var test = typeof(str);if(test.length == 6){    test.sign = &quot;typeof的返回结果可能为String&quot;;    // new String(test).sign = &apos;xxx&apos;;}// new String(test).signconsole.log(test.sign);// undefined</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象创建方法&quot;&gt;&lt;a href=&quot;#对象创建方法&quot; class=&quot;headerlink&quot; title=&quot;对象创建方法&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;对象创建方法&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;对象的创建方法有三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>预编译</title>
    <link href="http://yoursite.com/2018/11/19/js%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2018/11/19/js预编译/</id>
    <published>2018-11-19T09:16:33.000Z</published>
    <updated>2018-12-18T08:56:17.643Z</updated>
    
    <content type="html"><![CDATA[<p>• 我们在书写js代码的时候，会发现两点和c/c++语言不同的地方。第一个是当我们在后面定义了一个函数之后，我们在定义函数之前使用这个函数也是可以的。第二个是我们在后面声明的一个变量，但是在前面调用这个变量的时候并不会报错而是undefiend。</p><p>这两点不同在js中被称为<font color="red"><strong>函数声明提升</strong></font>和<font color="red"><strong>变量声明提升</strong></font>，函数声明提升是一种<font color="red"><strong>整体提升</strong></font>，它会把函数声明和函数体一起提升到前面。变量声明提升则是一种<font color="red"><strong>局部提升</strong></font>，它仅仅将变量的声明提前了，但是并没有将赋值也一起提前。</p><p>那么为什么会出现这种提升的现象呢？</p><p>这是因为js运行的时候有一个阶段叫做预编译阶段，而我们的声明提升现象都是发生在预编译的时候哟~</p><h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a><font color="red">预编译</font></h4><p>• js运行三部曲</p><p>1.语法分析</p><p>2.<font color="red">预编译</font></p><p>3.解释执行</p><p>语法分析：js引擎在解析js代码之前，会先通篇扫描一下，找出低级的语法错误，比如写错大括号之类的。</p><p>编译执行：js是一种解释型语言，编译一行执行一行，当语法分析没有问题，并且已经完成预编译阶段之后，就开始解释执行代码。</p><p>这里我们着重介绍预编译。</p><font color="red">预编译前奏</font><p>在介绍预编译之前，我们有两个重要概念需要掌握。</p><p>1.<font color="red">imply global 暗示全局变量。</font></p><p>如果任何变量未经声明就赋值使用，此变量就会为全局对象window所有，并且成为window对象的一个属性。</p><pre><code>window.a = 123;window.a === a ;// true</code></pre><p>或者</p><pre><code>a = 123;window.a === a ;// true</code></pre><p>2.一切<font color="red">声明</font>的全局变量，都是window的属性。</p><pre><code>var a = 123;console.log(window.a);// 123</code></pre><p>•这样看不论全局变量有没有声明，似乎都会成为全局对象上的属性，那么两者之间有什么区别呢？<br>区别在于：<font color="red">经过声明的全局变量不能通过delete操作来删除，但是未经声明的全局变量可以被删除。</font></p><pre><code>a = 123;console.log(window.a === a);// truedelete window.a;console.log(window.a);// undefiendvar b = 123;delete window.b;console.log(window.b);// 123</code></pre><p>正是这一种特性，导致es5有一种弊端，我们总会在无形中声明一些全局变量。</p><pre><code>function test(){    var a = b = 0;}</code></pre><p>这段代码的原意是：在函数体中声明两个变量a、b，然后初始化a、b都是0。但是我们这么写之后，a经过了声明，但是b却没有声明，这时候b就会成为一个全局变量。</p><font color="red">预编译的过程我总结为以下四步：</font><p>1.创建<font color="red">AO对象</font>。</p><p>2.<font color="red">寻找形参和变量声明</font>，将变量和形参作为AO对象的属性名添加到对象中，值为undefined。值得注意的是，函数声明不叫变量。</p><p>3.将<font color="red">实参值和形参值</font>相统一。</p><p>4.在函数体里面寻找<font color="red">函数声明</font>，将函数名作为属性名，值为这个函数的函数体。</p><p>函数在执行的前一刻会<font color="red">产生一个上下文</font>，这个上下文就是Activeaction Object对象，简称AO对象。</p><pre><code>即AO = {}</code></pre><p>这个对象是空的，但是里面有一些我们看不到的却存在的隐式属性，比如<font color="red">this: window</font>属性和<font color="red">arguments: [];</font>属性</p><p>这个对象用来存放一些属性和方法，这些属性和方法就按照前面的四步来产生。</p><p>这里我们用这一个样例代码来简单介绍一下预编译的过程。</p><pre><code>function fn(a, b){                       console.log(a);             function a(){}               a = 222;                 console.log(a);                                  function b (){}             console.log(b);         var b = 111;         var a ;                  }                                fn(1);  </code></pre><p>第一步:创建一个AO对象</p><pre><code>var AO = {};</code></pre><p>第二步:寻找形参值和变量声明，并且将值赋为undefined</p><pre><code>AO = {      a: undefiend,        b: undefiend}</code></pre><p>第三步:将实参值和形参值相统一</p><pre><code>AO = {     a: 1,     b: undefiend}</code></pre><p>第四步:寻找函数声明，将函数体赋值给属性</p><pre><code>AO = {     a: function(){},     b: function(){}}</code></pre><p>第一个console.log a –&gt; function () {}</p><p>第二个console.log a –&gt; 222 因为执行了a = 222这一行代码，所以重新赋值了。</p><p>第三个console.log b –&gt; function () {}</p><p>• <font color="red">var b = function () {}</font>这种不叫做函数声明，这个函数是赋值给b变量的，b变量是声明。</p><h4 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a><font color="red">更多例子</font></h4><p>例1</p><pre><code>function test(a, b){        console.log(a);        c = 0;        var c;        a = 3;        b = 2;        console.log(b);        function b(){}        function d(){}        console.log(b);}test(1);// 可以只传一个参数，即a=1 b=undefinedAO = {     a : 1     b : function b(){}     c : undefined     d : function d(){}}函数执行AO = {     a : 3     b : 2     c : 0     d : function d(){}}输出结果:1 2 2</code></pre><p>例2</p><pre><code>function test(a, b){        console.log(a);        console.log(b);        var b = 234;        console.log(b);        a = 123;        console.log(a);        function a(){}        var a;        b = 567;        var b = function(){}        console.log(a);        console.log(b);}test(1);AO = {     a : function a(){}     b : undefined }函数执行 AO = {     a : 123      b : function(){}}输出结果: function a(){} undefined 234 123 123 function(){}</code></pre><p>例3</p><pre><code>var a = 123;function a(){} 此时生成了一个GO 对象 Global Object     即GO===window   GO = {     a : 123} </code></pre><p>例4</p><pre><code>function test(){    var a = b = 123;    console.log(window.b);    console.log(window.a);}test();GO = {    b : 123}AO = {    a : undefiend}输出结果: 123 undefined</code></pre><p>例5</p><pre><code>console.log(test);function test(test){        console.log(test);        var test = 234;        console.log(test);        function test(){}}test(1);var test = 123;GO = {    test : function(){        // ...    }}AO = {    test : function test(){}}输出结果: function test(test){ ... } function test(){} 234</code></pre><p>例6</p><pre><code>global = 100;function fn(){        console.log(global);        global = 200;        console.log(global);        var global = 300;}fn();var global;GO = {    global : 100    fn : function fn(){}}AO = {    global : undefiend}输出结果: undefined 200</code></pre><p>例7</p><pre><code>function test(){        console.log(b);        if(a){          // a = undefined 不走if            var b = 100;        }        console.log(b);        c = 234;        console.log(c);}var a;test();a = 10;console.log(c);GO = {    a : undefiend    test : function test(){}    c : undefiend}AO = {    b : undefiend}输出结果: undefiend undefiend 234 234</code></pre><p>例8</p><pre><code>function bar(){        return foo;// 后面不走 直接返回        foo = 10;        function foo(){}        var foo = 11;}console.log(bar());GO = {    bar : function(){}}AO = {    foo : function foo(){} }输出结果: function foo(){}</code></pre><p>例9</p><pre><code>console.log(bar());function bar(){        foo = 10;        function foo(){}        var foo = 11;        return foo;}   GO = {    bar : function bar(){}}AO = {    foo : function foo(){}}输出结果: 11</code></pre><p>例10</p><pre><code>a = 100;function demo(e){    function e(){}    arguments[0] = 2;    console.log(e);    if(a){        var b = 123;        function c(){}    }    var c;    a = 10;    var a;    console.log(b);    f = 123;    console.log(c);    console.log(a);}var a;demo(1);console.log(a);console.log(f);GO = {    a : 100    demo : function (){}    f : 123}AO = {    a : undefiend    b : undefiend    c : undefiend    e : function e(){}}输出结果: 2 undefined undefined 10 100 123</code></pre><p>例11</p><pre><code>var x = 1,y = z = 0;function add(n){    return n = n +1;}y = add(x);function add(n){    return n = n + 3;}z = add(x);输出结果: x = 1 y = 4 z = 4</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;• 我们在书写js代码的时候，会发现两点和c/c++语言不同的地方。第一个是当我们在后面定义了一个函数之后，我们在定义函数之前使用这个函数也是可以的。第二个是我们在后面声明的一个变量，但是在前面调用这个变量的时候并不会报错而是undefiend。&lt;/p&gt;
&lt;p&gt;这两点不同在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>类型转换</title>
    <link href="http://yoursite.com/2018/11/18/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/11/18/数据类型转换/</id>
    <published>2018-11-18T09:16:33.000Z</published>
    <updated>2018-12-17T08:08:39.194Z</updated>
    
    <content type="html"><![CDATA[<h4 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title=" 显示类型转换"></a><font color="red"> 显示类型转换</font></h4><p>类型转换，自然是把数据的类型改变了，那么我们怎么才能知道数据的类型是否发生了改变呢？</p><p>我们有一个操作符<font color="red">typeof</font>可以检测数据的类型。</p><pre><code>console.log(typeof(123)); // number</code></pre><p>typeof能返回的类型一共只有6种：</p><font color="red"><strong>numner、string、boolean、undefined、object、function</strong></font><p>• <font color="red">数组和null</font>类型的都属于<font color="red">object</font>。其实null并不是一种对象，只是因为历史遗留性的问题，null通常用来作为对象占位符，所以被浏览器归到了object里面了。</p><p>• <font color="red">NaN</font>属于<font color="red">number</font>类型。虽然是非数，但是非数也是数字的一种。</p><p>• 同时，typeof返回的结果其实是一种字符串，我们可以用typeof来测试。</p><pre><code>console.log( typeof(typeof(a))); // string</code></pre><h4 id="1、转字符串"><a href="#1、转字符串" class="headerlink" title="1、转字符串"></a>1、转字符串</h4><p> 其实在js中，一切数据除了null 和undefined之外都自带一个函数，toString </p><pre><code>var n = 132.456n.toString();// &quot;123.456&quot;</code></pre><p>任何东西，都有toString 函数，toString函数可以将任何类型转换为string类型。</p><font color="red">但是</font>，有两个值没有toString ，<font color="red">null</font> 和 <font color="red">undefined</font><p>事实上在开发当中，String（x）这个用的绝对多，.toString(x)这个用的反而不多。</p><p>而且String(x)他是万能的，他可以转null 和 undefined</p><pre><code>var n = null;String(n);// &quot;null&quot;var a = undefined;String(n);// &quot;undefined&quot;</code></pre><h4 id="2、转数字"><a href="#2、转数字" class="headerlink" title="2、转数字"></a>2、转数字</h4><p>两种情况，第一种任意类型转数字，第二种专门的字符串转数字。<br>第一种 Number(x) 。它跟String(x)可不一样，它可不是万能的<br>只能转换纯数字组成的内容。还可以转布尔值。强调几点如下:</p><pre><code>Number(null); // 0Number(undefined); //NaNNumber(&quot;&quot;); // 0Number([]); // 0</code></pre><p>接下来字符串转数字，parseInt(str) 和 parseFloat(str)</p><font color="red"><strong>parseInt(string, radix)</strong></font><p>这个方法是将字符串转换成整型类型数字的。其中第二个参数radix基底是可以选择的参数。<br>当radix为空的时候，这个函数的作用仅仅是将字符串转换成数字。<br>当参数string里面既包括数字字符串又包括其他字符串的时候，它会将看到其他字符串就停止了，不会继续转换后面的数字型字符串了。</p><p>当radix不为空的时候，这个函数可以用来作为进制转换，第二个参数的作用则是，我们把第一个参数的数字<font color="red">当成几进制的数字来转换成十进制</font>。</p><p>• radix参数的范围是2-36。</p><pre><code>parseInt(3, 8);     //3       3以8进制为基础转换成10进制parseInt(3, 2);     //NaN     2进制里面没有三parseInt(3, 0);     //NaN     不存在0进制parseInt(&quot;010&quot;);    //未定：返回 10 或 8parseInt(&quot;1a&quot;);    //1parseInt(&quot;1234blue&quot;); //1234parseInt(‘abc123’) // NaNparseInt(&quot;&quot;);       //NaNparseInt(&quot;0xA&quot;)     //10(十六进制)parseInt(&quot;22.5&quot;);   //22</code></pre><h4 id="3、转布尔"><a href="#3、转布尔" class="headerlink" title="3、转布尔"></a>3、转布尔</h4><p>只有一个Boolean(x)，这个函数太强大了其他任何类型几乎都能转成布尔，只有五个值会被转成false</p><pre><code>Boolean(0);Boolean(NaN);Boolean(null);Boolean(undefined);Boolean(&quot;&quot;);</code></pre><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title=" 隐式类型转换"></a><font color="red"> 隐式类型转换</font></h4><p><strong>1.<font color="red">isNaN()</font></strong></p><p>这个方法可以检测数据是不是非数类型。</p><pre><code>isNaN(NaN); // trueisNaN(‘abc’); // trueisNaN(123); // false</code></pre><p>这中间隐含了一个隐式转换，它会先将你传的参数调用一下<font color="red">Number</font>方法之后，再看看结果是不是NaN，不过这个方法可以检测NaN本身。</p><p><strong>2.<font color="red">算术运算符</font></strong></p><p><strong>• ++就是现将数据调用一遍Number之后，再自加一。</strong></p><pre><code>var demo = &apos;abc&apos;;demo ++;// NaNdemo = &apos;123&apos;;++demo;// 124demo = &apos;123&apos;;demo ++;// 123</code></pre><p><strong>• 同样一目运算符也可以进行类型转换。</strong></p><pre><code>var num = false;+num ;// 0var demo = true;-demo ;// -1var demo = &apos;abc&apos;;+demo ;// NaN1 * &apos;2&apos; ;// 2true * false ;// 0false / false ;// NaNtrue / false ;// infinity无穷大-true / false ;// -infinity</code></pre><p><strong>• 逻辑运算符也会隐式调用类型转换</strong></p><p>&amp;&amp;和||都是先把表达式调用Boolean，换成布尔值再进行判断，看看是true还是false，不过返回的结果还是本身表达式的结果。</p><pre><code>!&apos;abc&apos;;// false</code></pre><p><strong>• 当然也有不发生类型转换的比较运算符</strong></p><font color="red">===严格等于</font><font color="red">!==严格不等于</font><pre><code>‘123’ === 123; // false; true === ‘true’; // false 1 !== ‘1’; // true 1 !== 1; // false</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;显示类型转换&quot;&gt;&lt;a href=&quot;#显示类型转换&quot; class=&quot;headerlink&quot; title=&quot; 显示类型转换&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt; 显示类型转换&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;类型转换，自然是把数据的类型改变了，那么我们怎么才能知
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3图片翻书展示()</title>
    <link href="http://yoursite.com/2018/11/17/CSS3%E5%9B%BE%E7%89%87%E7%BF%BB%E4%B9%A6%E5%B1%95%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/11/17/CSS3图片翻书展示/</id>
    <published>2018-11-17T09:20:12.000Z</published>
    <updated>2018-12-14T02:53:13.257Z</updated>
    
    <content type="html"><![CDATA[<pre><code>&lt;style&gt;        *{            margin: 0;            padding: 0;        }        body{            background-color: #fde3A7;            font-family: &apos;Indie Flower&apos;, cursive;/*字体  草书*/        }        .card{            width: 270px;            height: 400px;            position: absolute;            left: 50%;            top: 50%;            /* transform: translateX(-50%) translateY(-50%);CSS3 平移 */            margin-top: -200px;            margin-left: -150px;            box-shadow: inset 300px 0px 50px rgba(0, 0, 0, .5),20px 0 60px rgba(0, 0, 0, .5);/*阴影*/            perspective: 2000px;            transform-style: preserve-3d;            /* transform-origin: center center; */            transition:  all 1s ease-in-out;            background-color: #fff;        }        .card::before{  /*伪类和伪元素的区别  伪元素是真实存在的元素,能在html元素中存在的*/            content: &quot;&quot;;            display: inline-block;            width: 100%;            height: 5px;            background-color: #BAC1BA;            position: absolute;            top: -5px;            transform: skewX(-45deg);/*CSS3 扭曲*/            transform-origin: bottom;/*改变旋转中心*/        }        .card::after{            position: absolute;            right: -5px;             top: 0;            content: &quot;&quot;;            display: inline-block;            height: 100%;            width: 5px;            background-color: #BAC1BA;            transform: skewY(-45deg);/*CSS3 扭曲*/            transform-origin: left;        }        .card .imgBox{            position: absolute;            width: 100%;            height: 100%;            transform-origin: left;            transition:  all .7s ease-in-out;/*过渡*/        }        .card .imgBox .bark{            position: absolute;            width: 100%;            height: 100%;            background-color: #fff;            opacity: 0;            transition: all .6s ease-in-out;        }        .card .imgBox img{            width: 100%;        }        .card .details{            position: absolute;            width: 100%;            height: 100%;            top: 0;            left: 0;            z-index: -1;        }        .card:hover{   /*伪类是当前动作触发的*/             transform: rotateZ(15deg) scale(1.2);               box-shadow: inset 30px 0px 50px rgba(0, 0, 0, .5), 20px 0px 60px rgba(0, 0, 0, .5);        }        .card:hover .imgBox{            transform: rotateY(-135deg);        }        .card:hover .imgBox .bark{            opacity: 1;            transition:  all .6s ease-in-out;            box-shadow: inset 300px 200px 100px rgba(0, 0, 0, .5);         }    &lt;/style&gt;    &lt;div class=&quot;card&quot;&gt;        &lt;div class=&quot;imgBox&quot;&gt;            &lt;div class=&quot;bark&quot;&gt;&lt;/div&gt;            &lt;img src=&quot;./images/pic.jpg&quot; alt=&quot;&quot;&gt;        &lt;/div&gt;        &lt;!-- 翻开展示内容 --&gt;        &lt;div class=&quot;details&quot;&gt;            &lt;!-- 这里没有写第二页内容用图片代替 --&gt;            &lt;img src=&quot;./images/pic_.jpg&quot; alt=&quot;&quot;&gt;            &lt;!-- &lt;h4 class=&quot;title1&quot;&gt;内容标题1&lt;/h4&gt;            &lt;h4 class=&quot;title2&quot;&gt;内容标题2&lt;/h4&gt;            &lt;p&gt;内容...&lt;/p&gt;            &lt;p&gt;内容...&lt;/p&gt; --&gt;        &lt;/div&gt;    &lt;/div&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
        *{
            margin: 0;
            padding: 0;
        }
        body{
            background-color: #fd
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3之calc()</title>
    <link href="http://yoursite.com/2018/11/16/CSS3%E4%B9%8Bcalc()/"/>
    <id>http://yoursite.com/2018/11/16/CSS3之calc()/</id>
    <published>2018-11-16T09:18:33.000Z</published>
    <updated>2018-12-13T07:39:40.782Z</updated>
    
    <content type="html"><![CDATA[<p><font color="red"></font></p><h4 id="什么是calc"><a href="#什么是calc" class="headerlink" title="什么是calc()?"></a><font color="red">什么是calc()?</font></h4><p><strong>calc()</strong>从字面我们可以把他理解为一个函数function.其实calc是英文单词calculate(计算)的缩写,是css3的一个新增的功能,用来指定元素的长度.比如说,你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置<font color="red">动态值</font>.为何说是动态值呢?因为我们使用的表达式来得到的值.不过calc()最大的好处就是用在流体布局上,可以通过calc()计算得到元素的宽度.</p><h4 id="calc-能做什么"><a href="#calc-能做什么" class="headerlink" title="calc()能做什么?"></a><font color="red">calc()能做什么?</font></h4><p><font color="red">calc()能让你给元素的做计算</font>,你可以给一个div元素,使用百分比、em、px和rem单位值计算出其宽度或者高度,比如说”width:calc(50% + 2em)”,这样一来你就不用考虑元素DIV的宽度值到底是多少,而把这个烦人的任务交由浏览器去计算.</p><h4 id="calc-语法"><a href="#calc-语法" class="headerlink" title="calc()语法"></a><font color="red">calc()语法</font></h4><p>calc()语法非常简单,就像我们小时候学加(+)、减(-)、乘(*)、除(/)一样,使用数学表达式来表示:</p><pre><code>.elm{    width: calc(expression)}</code></pre><p>其中”expression”是一个表达式，用来计算长度的表达式.</p><h4 id="calc-的运算规则"><a href="#calc-的运算规则" class="headerlink" title="calc()的运算规则"></a><font color="red">calc()的运算规则</font></h4><p>calc()使用通用的数学运算规则,但是也提供更智能的功能:</p><p>• 使用”+”、”-“、”*” 和 “/“四则运算;</p><p>• 可以使用百分比、px、em、rem等单位;</p><p>• 可以混合使用各种单位进行计算;</p><p>• 表达式中有”+”和”-“时,其<font color="red">前后必须要有空格</font>,如”widht: calc(12%+5em)”这种没有空格的写法是错误的;</p><p>• 表达式中有”*”和”/“时,其<font color="red">前后可以没有空格</font>,但建议留有空格.</p><h4 id="浏览器的兼容性"><a href="#浏览器的兼容性" class="headerlink" title="浏览器的兼容性"></a><font color="red">浏览器的兼容性</font></h4><p>浏览器对calc()的兼容性还算不错,在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持,同样需要在其前面加上各浏览器厂商的识别符,不过可惜的是,移动端的浏览器还没仅有“firefox for android 14.0”支持,其他的全军覆没.大家在实际使用时,同样需要添加浏览器的前缀</p><pre><code>.elm {    //Firefox    -moz-calc(expression);    //chrome safari    -webkit-calc(expression);    //Standard    calc();}</code></pre><p><strong>例1.</strong></p><pre><code>.demo{    width: 300px;    background: #60f;    padding: 3px 0;}.box{    background: #f60;    height: 50px;    padding: 10px;    border: 5px solid green;    width: 90%;/*写给不支持calc()的浏览器*/    width: -moz-calc(100% - (10px + 5px) * 2);    width: -webkit-calc(100% - (10px + 5px) * 2);    width: calc(100% - (10px + 5px) * 2);}&lt;div class=&quot;demo&quot;&gt;    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;hr&gt;</code></pre><p><img src="https://i.imgur.com/HugB59A.png" alt=""></p><p><strong>例2.</strong></p><pre><code>body{       background: #E8EADD;       color: #3C323A;       padding: 20px;   }   /*设置主容器&quot;wrapper&quot;     主容器的宽度是:&quot;100% - 20px * 2,并且水平居中&quot;   */   .wrapper{       width: 1024px;/*写给不支持calc()的浏览器*/       width: -moz-calc(100% - 40px);       width: -webkit-calc(100% - 40px);       width: calc(100% - 40px);       margin: auto;   }   /*给header和footer设置样式     对应的宽度是:&quot;100% - 20px * 2   */   #header{       background: #f60;       padding: 20px;       width: 984px;       width: -moz-calc(100% - 40px);       width: -webkit-calc(100% - 40px);       width: calc(100% - 40px);   }   #footer{       clear: both;       background: #000;       padding: 20px;       color: #fff;       width: 984px;       width: -moz-calc(100% - 40px);       width: -webkit-calc(100% - 40px);       width: calc(100% - 40px);   }   /*给主内容设置样式     给主内容设置一个8px的边框,20px的内距,并且向左浮动,同时设置一个向右的外边距&quot;20&quot;px     关键之处,我们主内容占容器宽度的75%,这样一来,主内容的宽度应该是:     &quot;75% - 8px * 2 - 20px * 2&quot;   */   #main{       border: 8px solid #B8C172;       float: left;       padding: 20px;       margin-right: 20px;       margin-bottom: 20px;       width: 704px;       width: -moz-calc(75% - 20px * 2 - 8px * 2);       width: -webkit-calc(75% - 20px * 2 - 8px * 2);       width: calc(75% - 20px * 2 - 8px * 2);   }   /*设置右边栏样式     给边栏设置一个25%的宽度,其除了包含8px的边框,10px的内距外,还有主内容外距20px也要去掉     不然整个宽度与容器会相差20px,换句话说就会撑破容器掉下来.因此边栏的实际宽度应该是:     &quot;25% - 10px * 2 - 8px * 2 -20px&quot;     */   #accessory{       border: 8px solid #B8C172;       float: left;       padding: 10px;       width: 208px;       width: -moz-calc(25% - 10px * 2 - 8px * 2 - 20px);       width: -webkit-calc(25% - 10px * 2 - 8px * 2 - 20px);       width: calc(25% - 10px * 2 - 8px * 2 - 20px);   }   &lt;div class=&quot;wrapper&quot;&gt;       &lt;div id=&quot;header&quot;&gt;header&lt;/div&gt;       &lt;div id=&quot;main&quot;&gt;main&lt;/div&gt;       &lt;div id=&quot;accessory&quot;&gt;accessory&lt;/div&gt;       &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt;   &lt;/div&gt;</code></pre><p><img src="https://i.imgur.com/gF8nD6v.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font color=&quot;red&quot;&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是calc&quot;&gt;&lt;a href=&quot;#什么是calc&quot; class=&quot;headerlink&quot; title=&quot;什么是calc()?&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;什么是calc()?&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3之阴影</title>
    <link href="http://yoursite.com/2018/11/15/CSS3%E4%B9%8B%E9%98%B4%E5%BD%B1/"/>
    <id>http://yoursite.com/2018/11/15/CSS3之阴影/</id>
    <published>2018-11-15T09:17:33.000Z</published>
    <updated>2018-12-13T07:39:36.171Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-盒子阴影"><a href="#1-盒子阴影" class="headerlink" title="1. 盒子阴影"></a><font color="red">1. 盒子阴影</font></h4><font color="red"><strong>box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];</strong></font><p>例如  box-shadow:4px 2px 6px 7px #333333 inset;</p><p>同一盒子，可以同时加多个阴影，阴影之间用”,”隔开</p><p>例如  box-shadow:4px 2px 6px #f00,-4px -2px 6px #000,0px 0px 12px 5px #33CC00 inset;</p><h4 id="2-字体阴影"><a href="#2-字体阴影" class="headerlink" title="2. 字体阴影"></a><font color="red">2. 字体阴影</font></h4><p>text-shadow:X-Offset Y-Offset blur color;</p><ol><li><font color="red">X-Offset</font>:表示阴影的水平偏移距离,其值为正值时阴影向右偏移,反之向左偏移;</li><li><font color="red">Y-Offset</font>:是指阴影的垂直偏移距离,如果其值是正值时,阴影向下偏移,反之向上偏移;</li><li><font color="red">Blur</font>:是指阴影的模糊程度,其值不能是负值,如果值越大,阴影越模糊,反之阴影越清晰,如果不需要阴影模糊可以将Blur值设置为0;</li><li><font color="red">Color</font>:是指阴影的颜色,其可以使用rgba色;</li></ol><pre><code>*{    margin: 0;    padding: 0;}div{    /*3. 实现书摆放在桌子上的效果*/    width: 200px;    height: 200px;    background-color: red;    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%,-50%);    background: #e0e1dc;    text-align: center;    line-height: 200px;    color: #fff;    font-weight: 900;    font-size: 24px;    text-shadow: 5px 2px 3px grey;    box-shadow: 10px 0 10px 0 grey;}&lt;div&gt;This is a page&lt;/div&gt;</code></pre><p><img src="https://i.imgur.com/nllEayT.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-盒子阴影&quot;&gt;&lt;a href=&quot;#1-盒子阴影&quot; class=&quot;headerlink&quot; title=&quot;1. 盒子阴影&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;1. 盒子阴影&lt;/font&gt;&lt;/h4&gt;&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;box-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3新增背景属性</title>
    <link href="http://yoursite.com/2018/11/14/CSS3%E6%96%B0%E5%A2%9E%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/11/14/CSS3新增背景属性/</id>
    <published>2018-11-14T09:17:33.000Z</published>
    <updated>2018-12-14T02:49:30.944Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-background-origin-背景的起始位置"><a href="#1-background-origin-背景的起始位置" class="headerlink" title="1.background-origin 背景的起始位置"></a><font color="red">1.background-origin 背景的起始位置</font></h4><p> background-origin: border-box || padding-box || content-box;</p><p> background-Origin属性指定了背景图像的位置区域。</p><p> content-box, padding-box,和 border-box区域内可以放置背景图像。</p><p><img src="https://i.imgur.com/6sqcM3E.png" alt=""></p><p>效果: 设置的盒子存在 border padding content(用户设置的width height)</p><p>1.padding-box(默认值); 设置背景图片的位置从padding(内边距)开始放置</p><pre><code>将border设置为透明，方便查看不同属性的效果div{        width: 600px;        height: 400px;         padding: 30px;        border: 50px solid rgba(104, 104, 98, .3);        background-image: url(&apos;./images/g.jpg&apos;);        background-repeat: no-repeat;        background-size: 100%;        background-origin: padding-box;    }&lt;div&gt;&lt;/div&gt;</code></pre><p><img src="https://i.imgur.com/FfrdQdM.png" alt=""></p><p>2.border-box; 设置背景图片的起始位置从border开始 </p><pre><code>div{        width: 600px;        height: 400px;         padding: 30px;        border: 50px solid rgba(104, 104, 98, .3);        background-image: url(&apos;./images/g.jpg&apos;);        background-repeat: no-repeat;        background-size: 100%;        background-origin: border-box;    }</code></pre><p><img src="https://i.imgur.com/HqhZHyP.png" alt=""></p><p>3.content-box; 设置背景图片的位置从用户设置的内容区开始放置</p><pre><code>div{        width: 600px;        height: 400px;         padding: 30px;        border: 50px solid rgba(104, 104, 98, .3);        background-image: url(&apos;./images/g.jpg&apos;);        background-repeat: no-repeat;        background-size: 100%;        background-origin: content-box    }</code></pre><p><img src="https://i.imgur.com/cGEPCMS.png" alt=""></p><h4 id="2-background-clip-背景裁剪"><a href="#2-background-clip-背景裁剪" class="headerlink" title="2.background-clip 背景裁剪"></a><font color="red">2.background-clip 背景裁剪</font></h4><p>   background-clip: border-box || padding-box || content-box || no-clip</p><p>效果:背景图片默认不裁剪 案例设置了背景图片的起始位置 为boder部分开始 </p><p>1.no-clip（默认值）; 不裁剪背景图片。</p><pre><code>div{    width: 600px;    height: 400px;     padding: 30px;    border: 50px solid rgba(104, 104, 98, .3);    background-image: url(&apos;./images/g.jpg&apos;);    background-repeat: no-repeat;    background-size: 100%;    background-clip: no-clip;}&lt;div&gt;&lt;/div&gt;</code></pre><p><img src="https://i.imgur.com/cIcEAfG.png" alt=""></p><p>2.padding-box; 保留padding + content 部分的背景图片将padding以外的背景图片裁剪掉</p><pre><code>div{    width: 600px;    height: 400px;     padding: 30px;    border: 50px solid rgba(104, 104, 98, .3);    background-image: url(&apos;./images/g.jpg&apos;);    background-repeat: no-repeat;    background-size: 100%;    background-clip: padding-box;}</code></pre><p><img src="https://i.imgur.com/5TTaZxn.png" alt=""></p><p>3.content-box; 保留content 部分的背景图片将content以外的背景图片裁剪掉</p><pre><code>    div{    width: 600px;    height: 400px;     padding: 30px;    border: 50px solid rgba(104, 104, 98, .3);    background-image: url(&apos;./images/g.jpg&apos;);    background-repeat: no-repeat;    background-size: 100%;    background-clip: content-box;}</code></pre><p><img src="https://i.imgur.com/JDUlVmS.png" alt=""></p><p>4.border-box; 保留border以内的背景图片将border以外的背景图片裁剪掉。</p><pre><code>        div{    width: 600px;    height: 400px;     padding: 30px;    border: 50px solid rgba(104, 104, 98, .3);    background-image: url(&apos;./images/g.jpg&apos;);    background-repeat: no-repeat;    background-size: 100%;    background-clip: border-box;}</code></pre><p><img src="https://i.imgur.com/fpuDeW0.png" alt=""></p><p> 注意: border-box和no-clip 的效果相同 但是含义不同</p><h4 id="3-background-size-背景图片大小"><a href="#3-background-size-背景图片大小" class="headerlink" title="3.background-size 背景图片大小"></a><font color="red">3.background-size 背景图片大小</font></h4><p>  background-size: cover || contain || 百分比 || 像素值</p><pre><code>div{    width: 600px;    height: 400px;     padding: 30px;    border: 10px solid rgba(104, 104, 98, .5);    background-image: url(&apos;./images/g.jpg&apos;);    background-repeat: no-repeat;}&lt;div&gt;&lt;/div&gt;</code></pre><p><img src="https://i.imgur.com/JmaEys4.png" alt=""></p><p>1.cover: 覆盖 图片会按照指定比例放大或缩小的填充,放大缩小的比例取决于图片的宽:放置的盒子的内容区的宽和图片的高:放置在盒子的内容区的高的大小的取较大的一个。</p><pre><code>div{        width: 600px;        height: 400px;         padding: 30px;        border: 10px solid rgba(104, 104, 98, .5);        background-image: url(&apos;./images/g.jpg&apos;);        background-repeat: no-repeat;        background-size: cover;    }</code></pre><p><img src="https://i.imgur.com/48yV8Pg.png" alt=""></p><p>2.contain: 包含 图片会按照指定比例扩大或缩小的填充,放大缩小的比例取决于图片的宽:放置的盒子的内容区的宽和图片的高:放置在盒子的内容区的高的大小的取较小的一个。</p><pre><code>div{        width: 600px;        height: 400px;         padding: 30px;        border: 10px solid rgba(104, 104, 98, .5);        background-image: url(&apos;./images/g.jpg&apos;);        background-repeat: no-repeat;        background-size: contain;    }</code></pre><p><img src="https://i.imgur.com/CHOZHYs.png" alt=""></p><p>3.一个具体像素值(若是百分比则表示相对于可显示区的大小)代表的是图片的宽度扩大或缩放到该像素值,而图片的宽高比是不变的</p><pre><code>div{        width: 600px;        height: 400px;         padding: 30px;        border: 10px solid rgba(104, 104, 98, .5);        background-image: url(&apos;./images/g.jpg&apos;);        background-repeat: no-repeat;        background-size: 210px;    }</code></pre><p><img src="https://i.imgur.com/Dmn7xVl.png" alt=""></p><p>4.两个具体像素值(若是百分比则表示相对于可显示区的大小)代表的是图片的宽度和高度分别缩放或扩大到指定像素值,图片的宽高比取决于设置的像素比</p><pre><code>div{        width: 600px;        height: 400px;         padding: 30px;        border: 10px solid rgba(104, 104, 98, .5);        background-image: url(&apos;./images/g.jpg&apos;);        background-repeat: no-repeat;        background-size: 400px 400px;    }</code></pre><p><img src="https://i.imgur.com/bRo38OL.png" alt=""></p><h4 id="4-background-image-背景图片"><a href="#4-background-image-背景图片" class="headerlink" title="4.background-image 背景图片"></a><font color="red">4.background-image 背景图片</font></h4><p>CSS3中可以通过background-image属性添加背景图片。</p><p>不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。</p><pre><code>&lt;style&gt;#examplel{        width: 658px;        height: 1059px;        background-image: url(&apos;./images/bg2.png&apos;),         url(&apos;./images/cat1.png&apos;), url(&apos;./images/cat2.png&apos;),         url(&apos;./images/cat3.png&apos;), url(&apos;./images/cat4.png&apos;),         url(&apos;./images/cat5.png&apos;), url(&apos;./images/cat6.png&apos;);        background-position: left top ,        left top, right top, center top,         left center, center, 200px 200px;        background-repeat: no-repeat;        padding: 15px;}&lt;/style&gt;&lt;div id=&quot;examplel&quot;&gt;&lt;/div&gt;</code></pre><p><img src="https://i.imgur.com/DlCySK9.png" alt=""></p><h4 id="5-background-position-背景定位"><a href="#5-background-position-背景定位" class="headerlink" title="5.background-position 背景定位"></a><font color="red">5.background-position 背景定位</font></h4><p>  background-position: left top || left bottom || right top || right bottom || center center || 像素值 || 百分比</p><p>(注: 没写的参数都是默认值center)</p><p>1.设置background-position:left top 代表背景图片要放在内容区的左上角的位置（默认值）</p><p>2.设置background-position: left; 将背景图片要放在内容区的左侧中间的位置 </p><p>   设置background-position: left bottom; 将背景图片要放在内容区的左下角的位置</p><p>3.设置background-position: right; 将背景图片要放在内容区的右侧中间的位置</p><p>4.设置background-position: right top; 将背景图片要放在内容区的右侧上角的位置</p><p>5.设置background-position: right bottom; 将背景图片要放在内容区的右侧下角的位置</p><p>6.设置background-position: center; 将背景图片要放在内容区中间的位置</p><p>7.设置background-position: 100px;       即沿x轴平移100px;</p><p>8.设置background-position: 100px 100px; 将背景图片要放在内容区水平位置100px 垂直位置100px的位置,即沿x轴平移100px，沿y轴平移100px</p><p>9.设置background-position: 20%;      将背景图片要放在内容区水平位置20%的位置。 </p><p>10.设置background-position: 20% 20%; 将背景图片要放在内容区水平位置20%，竖直位置20% 的位置。</p><p>第一个参数:0%是最左边 100%是最右边 中间平分。第二个参数： 0%是最上边，100%是最下边 中间平分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-background-origin-背景的起始位置&quot;&gt;&lt;a href=&quot;#1-background-origin-背景的起始位置&quot; class=&quot;headerlink&quot; title=&quot;1.background-origin 背景的起始位置&quot;&gt;&lt;/a&gt;&lt;font
      
    
    </summary>
    
    
  </entry>
  
</feed>
