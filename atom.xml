<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>welcome</title>
  
  <subtitle>求知若饥，虚心若愚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-14T02:46:15.375Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wanghai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS3动画</title>
    <link href="http://yoursite.com/2018/12/13/CSS3%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/12/13/CSS3动画/</id>
    <published>2018-12-13T09:55:59.000Z</published>
    <updated>2018-12-14T02:46:15.375Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CSS3，我们可以创建动画，它可以取代许多网页动画图像，Flash动画，和JAVAScripts。</strong></p><style>            #ppxiong{                width: 76px;                height: 47px;                background: #92B901 none repeat scroll 0% 0%;                position: relative;                color: #fff;                font-weight: bold;                font-size: 20px;                padding: 10px;                border-radius: 5px;                animation: first 5s ease 0s normal none 3 running;            }            @keyframes first            {                0% {background: red;  transform: rotate(0deg);left: 0;}                25%{background: pink; transform: rotate(20deg);left: 0;}                50%{background: blue; transform: rotate(0deg);left: 500px;}                55%{background: green; transform: rotate(0deg);left: 500px;}                70%{background: #1ec7e6; transform: rotate(0deg);left: 500px;}                100% {background: yellow; transform: rotate(-360deg);left: 0;}            }</style><div id="ppxiong">CSS3</div><p>浏览器支持<br>Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。</p><p>当在@keyframe创建动画，把它绑定到一个选择器，否则动画不会有任何效果。<br>指定至少这两个CSS3的动画属性绑定向一个选择器：</p><ul><li><p>规定动画的名称</p></li><li><p>规定动画的时长</p></li></ul><style>        #showtime{            width: 100px;            height: 100px;            background: red;            animation: myfirst 5s;        }        @keyframes myfirst        {            from {background: red;}            to {background: yellow;}        }</style><div id="showtime"></div><pre><code>把 &quot;myfirst&quot; 动画捆绑到 div 元素，时长：5 秒：&lt;style&gt;   div{        width: 100px;        height: 100px;        background: red;        animation: myfirst 5s;    }   @keyframes myfirst   {        from {background:red;}        to {background:yellow;}    }&lt;/style&gt;&lt;div&gt;&lt;/div&gt;</code></pre><p>必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0。</p><font color="red"><strong>CSS3动画是什么？</strong></font><p>• 动画是使元素从一种样式逐渐变化为另一种样式的效果。</p><p>• 您可以改变任意多的样式任意多的次数。</p><p>• 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p><p>• 0% 是动画的开始，100% 是动画的完成。</p><p>• 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p><pre><code>&lt;style&gt; div{    width:100px;    height:100px;    background:red;    animation:myfirst 5s;    -moz-animation:myfirst 5s; /* Firefox */    -webkit-animation:myfirst 5s; /* Safari and Chrome */    -o-animation:myfirst 5s; /* Opera */}@keyframes myfirst{    0%   {background:red;}    25%  {background:yellow;}    50%  {background:blue;}    100% {background:green;}}@-moz-keyframes myfirst /* Firefox */{    0%   {background:red;}    25%  {background:yellow;}    50%  {background:blue;}    100% {background:green;}}@-webkit-keyframes myfirst /* Safari and Chrome */{    0%   {background:red;}    25%  {background:yellow;}    50%  {background:blue;}    100% {background:green;}}@-o-keyframes myfirst /* Opera */{    0%   {background:red;}    25%  {background:yellow;}    50%  {background:blue;}    100% {background:green;}}&lt;/style&gt;&lt;div&gt;&lt;/div&gt; </code></pre><font color="red"><strong>CSS3的动画属性</strong></font><pre><code>@keyframes                  关键帧: 规定动画animation                   所有动画属性的简写属性,除了animation-play-state animation-name              规定 @keyframes 动画的名称animation-duration          规定动画完成一个周期所花费的秒或毫秒。默认是 0animation-timing-function   规定动画的速度曲线(运动速度函数)。默认是 &quot;ease&quot;animation-delay             规定动画何时开始(延迟时间)。默认是 0animation-iteration-count   规定动画执行的次数  infinite(无限循环)animation-direction         规定动画是否在下一周期逆向地播放。默认是 &quot;normal&quot;animation-fill-mode         属性规定动画在播放之前或之后，其动画效果是否可见animation-play-state        规定动画是否正在运行或暂停。默认是 &quot;running&quot;</code></pre><style>    #CSS3animation{        width: 100px;        height: 100px;        background: red;        position: relative;        animation: animationdemo 3s ease 2s infinite alternate-reverse running;    }      @keyframes animationdemo    {        0%   {background:red; left:0px; top:0px;}        15%  {background:yellow; left:300px; top:0px;}        30%  {background:blue; left:300px; top:100px;}        45%  {background:green; left:600px; top:100px;}        60%  {background:green; left:300px; top:100px;}        75%  {background:yellow; left:300px; top:0px;}        100%   {background:red; left:0px; top:0px;}    }    @-webkit-keyframes animationdemo    {        0%   {background:red; left:0px; top:0px;}        15%  {background:yellow; left:300px; top:0px;}        30%  {background:blue; left:300px; top:100px;}        45%  {background:green; left:600px; top:100px;}        60%  {background:green; left:300px; top:100px;}        75%  {background:yellow; left:300px; top:0px;}        100%   {background:red; left:0px; top:0px;}    }   </style><div id="CSS3animation"></div><pre><code>&lt;style&gt;#demo{    width: 100px;    height: 100px;    background: red;    position: relative;    animation: animationdemo 3s ease 2s infinite alternate-reverse running;}  @keyframes animationdemo{    0%   {background:red; left:0px; top:0px;}    15%  {background:yellow; left:300px; top:0px;}    30%  {background:blue; left:300px; top:100px;}    45%  {background:green; left:600px; top:100px;}    60%  {background:green; left:300px; top:100px;}    75%  {background:yellow; left:300px; top:0px;}    100%   {background:red; left:0px; top:0px;}}@-webkit-keyframes animationdemo{    0%   {background:red; left:0px; top:0px;}    15%  {background:yellow; left:300px; top:0px;}    30%  {background:blue; left:300px; top:100px;}    45%  {background:green; left:600px; top:100px;}    60%  {background:green; left:300px; top:100px;}    75%  {background:yellow; left:300px; top:0px;}    100%   {background:red; left:0px; top:0px;}}   &lt;/style&gt;&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;CSS3，我们可以创建动画，它可以取代许多网页动画图像，Flash动画，和JAVAScripts。&lt;/strong&gt;&lt;/p&gt;
&lt;style&gt;
            #ppxiong{
                width: 76px;
       
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3渐变</title>
    <link href="http://yoursite.com/2018/12/12/CSS3%E6%B8%90%E5%8F%98/"/>
    <id>http://yoursite.com/2018/12/12/CSS3渐变/</id>
    <published>2018-12-12T09:55:59.000Z</published>
    <updated>2018-12-14T08:49:34.455Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CSS3-渐变（Gradients）"><a href="#CSS3-渐变（Gradients）" class="headerlink" title="CSS3 渐变（Gradients）"></a>CSS3 渐变（Gradients）</h4><div id="gradl11" style="font-size: 36px ;text-align: center;height: 55px;line-height:55px;background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);">Gradient Background</div><ul><li>CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。</li><li>以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的事件和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。</li><li>CSS3 定义了两种类型的渐变（gradients）：<br>1.<font color="red"><strong>线性渐变（Linear Gradients）</strong></font>- 向下/向上/向左/向右/对角方向<br>2.<font color="red"><strong>径向渐变（Radial Gradients）</strong></font>- 由它们的中心定义</li></ul><p><strong>浏览器支持</strong></p><p>后边跟 -webkit-、-moz- 或 -o- 的数字指定了需加上前缀才能支持属性的第一个版本。</p><p>完全支持该属性(4个属性)的第一个浏览器版本。</p><pre><code>IE          10.0chrome      26.0  10.0-webkit-Firefox     16.0  3.6 -moz-Safari      6.1   5.1 -webkit-Opera       12.1  11.1 -o-</code></pre><h4 id="CSS3-线性渐变"><a href="#CSS3-线性渐变" class="headerlink" title="CSS3 线性渐变"></a>CSS3 线性渐变</h4><p>为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。</p><p><strong>语法</strong></p><pre><code>background: linear-gradient(direction, color-stop1, color-stop2, ...);  </code></pre><p><strong>线性渐变 - 从上到下（默认情况下）</strong></p><div id="gradl1" style="height: 200px;background: linear-gradient(red, blue);"></div><pre><code>&lt;style&gt;    #grad1 {        height: 200px;        background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */        background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */        background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */        background: linear-gradient(red, blue); /* 标准的语法（必须放在最后） */    }&lt;/style&gt;&lt;div id=&quot;grad1&quot;&gt;&lt;/div&gt;</code></pre><p><strong>线性渐变 - 从左到右</strong></p><div style="height: 200px; background: linear-gradient(to right, red, blue);"></div><pre><code>#grad1 {    height: 200px;    background: linear-gradient(to right, red , blue); }</code></pre><p><strong>线性渐变 - 对角</strong><br>从左上角开始（到右下角）的线性渐变。起点是红色，慢慢过渡到蓝色：</p><div style="height: 200px;background: linear-gradient(to bottom right, red, blue);"></div><pre><code>#grad1 {    height: 200px;    background: linear-gradient(to bottom right, red , blue); }</code></pre><p><strong>使用角度</strong></p><p>如果你想要在渐变的方向上做更多的控制，你可以定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）。</p><pre><code>background: linear-gradient(angle, color-stop1, color-stop2);     </code></pre><p>角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。</p><p><img src="https://i.imgur.com/NhvHymM.png" alt=""></p><p>下面的实例演示了如何在线性渐变上使用角度：</p><pre><code>0deg - 从下到上background: linear-gradient(0deg, red, blue);</code></pre><div style="height: 100px;background: linear-gradient(0deg, red, blue);"></div><pre><code>90deg - 从左到右background: linear-gradient(90deg, red, blue);</code></pre><div style="height: 100px;background: linear-gradient(90deg, red, blue);"></div><br>        180deg - 从上到下<br>        background: linear-gradient(180deg, red, blue);<br><div style="height: 100px;background: linear-gradient(180deg, red, blue);"></div><br>        -90deg - 从右到左<br>        background: linear-gradient(-90deg, red, blue);<br><div style="height: 100px;background: linear-gradient(-90deg, red, blue);"></div><br><br><br><br><strong>使用多个颜色结点</strong><br><br><br><div style=" height: 200px;background: linear-gradient(red, green, blue);"></div>    <pre><code>3 个颜色结点（均匀分布）background: linear-gradient(red, green, blue);</code></pre><div style="height: 200px;background: linear-gradient(red 10%, green 85%, blue 90%);"></div><pre><code>3 个颜色结点（不均匀分布）background: linear-gradient(red 10%, green 85%, blue 90%);</code></pre><div style="height: 200px;background: linear-gradient(red, orange,  yellow, green, blue,indigo, violet);"></div><pre><code>7 个颜色结点（均匀分布）background: linear-gradient(red, orange,  yellow, green, blue, indigo, violet);</code></pre><h4 id="创建一个带有彩虹颜色和文本的线性渐变"><a href="#创建一个带有彩虹颜色和文本的线性渐变" class="headerlink" title="创建一个带有彩虹颜色和文本的线性渐变"></a>创建一个带有彩虹颜色和文本的线性渐变</h4><pre><code>#grad1 {    height: 55px;    background: -webkit-linear-gradient(left, red, orange, yellow, green, blue, indigo, violet); /* Safari 5.1 - 6.0 */    background: -o-linear-gradient(left, red, orange, yellow, green, blue, indigo, violet); /* Opera 11.1 - 12.0 */    background: -moz-linear-gradient(left, red, orange, yellow, green, blue, indigo, violet); /* Firefox 3.6 - 15 */    background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet); /* 标准的语法（必须放在最后） */}</code></pre><p><strong>使用透明度（Transparency）</strong></p><p>CSS3 渐变也支持透明度（transparency），可用于创建减弱变淡的效果。</p><p>为了添加透明度，我们使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。</p><p>下面的实例演示了从左边开始的线性渐变。起点是完全透明，慢慢过渡到完全不透明的红色：</p><div style="height: 200px;background: linear-gradient(to right, rgba(255, 0, 0, 0), rgba(255, 0, 0, 1));"></div><pre><code>background: linear-gradient(to right, rgba(255, 0, 0, 0), rgba(255, 0, 0, 1));</code></pre><p><strong>重复的线性渐变</strong></p><p>repeating-linear-gradient() 函数用于重复线性渐变：</p><div style="height: 200px;background: repeating-linear-gradient(red, yellow 10%, green 20%);"></div><pre><code>background: repeating-linear-gradient(red, yellow 10%, green 20%);</code></pre><h4 id="CSS3-径向渐变"><a href="#CSS3-径向渐变" class="headerlink" title="CSS3 径向渐变"></a>CSS3 径向渐变</h4><p>径向渐变由它的中心定义。</p><p>为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p><p><strong>语法</strong></p><pre><code>background: radial-gradient(center, shape size, start-color, ..., last-color);</code></pre><p><strong>径向渐变 - 颜色结点均匀分布（默认情况下）</strong></p><div style="height: 150px;width: 200px;background: radial-gradient(red, orange, violet);"></div><pre><code>#gradl1{       height: 150px;       width: 200px;       background: radial-gradient(red, orange, violet);   }   </code></pre><p><strong>径向渐变 - 颜色结点不均匀分布</strong></p><div style="height: 150px;width: 200px;background: radial-gradient(red 5%, orange 15%, violet 60%);"></div><pre><code>#gradl1{       height: 150px;       width: 200px;       background: radial-gradient(red 5%, orange 15%, violet 60%);   } </code></pre><p><strong>设置形状</strong></p><p>shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。</p><div style="height: 150px;width: 200px;background: radial-gradient( red, yellow, green);"></div><pre><code>#gradl1{        height: 150px;        width: 200px;        background: radial-gradient(red, yellow, green);    }</code></pre><div style="height: 150px;width: 200px;background: radial-gradient(circle ,  red, yellow, green);"></div><pre><code>#gradl1{        height: 150px;        width: 200px;        background: radial-gradient(circle, red, yellow, green);    }</code></pre><p><strong>不同尺寸大小关键字的使用</strong></p><p>size 参数定义了渐变的大小。它可以是以下四个值：</p><p><strong>• closest-side</strong><br><strong>• farthest-side</strong><br><strong>• closest-corner</strong><br><strong>• farthest-corner</strong></p><div style="height: 150px;width: 150px;background: -webkit-radial-gradient(60% 55%, closest-side,blue,green,yellow,black);"></div><pre><code>background: -webkit-radial-gradient(60% 55%, closest-side,blue,green,yellow,black);</code></pre><div style="height: 150px;width: 150px;background: -webkit-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black);"></div><pre><code>background: -webkit-radial-gradient(60% 55%, farthest-side,blue,green,yellow,black);</code></pre><div style="height: 150px;width: 150px;background: -webkit-radial-gradient(60% 55%, closest-corner,blue,green,yellow,black);"></div><pre><code>background: -webkit-radial-gradient(60% 55%, closest-corner,blue,green,yellow,black);</code></pre><div style="height: 150px;width: 150px;background: -webkit-radial-gradient(60% 55%, farthest-corner,blue,green,yellow,black);"></div><pre><code>background: -webkit-radial-gradient(60% 55%, farthest-corner,blue,green,yellow,black);</code></pre><p><strong>重复的径向渐变</strong></p><p>repeating-radial-gradient() 函数用于重复径向渐变：</p><div style="height: 150px;width: 200px;background: repeating-radial-gradient(   #EE2C2C, black 20%)"></div><pre><code>#gradl{    height: 150px;    width: 200px;    background: repeating-radial-gradient(#EE2C2C, black 20%);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;CSS3-渐变（Gradients）&quot;&gt;&lt;a href=&quot;#CSS3-渐变（Gradients）&quot; class=&quot;headerlink&quot; title=&quot;CSS3 渐变（Gradients）&quot;&gt;&lt;/a&gt;CSS3 渐变（Gradients）&lt;/h4&gt;&lt;div id=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3弹性盒子</title>
    <link href="http://yoursite.com/2018/12/11/CSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90/"/>
    <id>http://yoursite.com/2018/12/11/CSS3弹性盒子/</id>
    <published>2018-12-11T09:55:59.000Z</published>
    <updated>2018-12-17T07:12:57.597Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS常用命名规范</title>
    <link href="http://yoursite.com/2018/12/10/CSS%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/12/10/CSS常用命名规范/</id>
    <published>2018-12-10T09:16:33.000Z</published>
    <updated>2018-12-17T08:19:01.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="class的命名"><a href="#class的命名" class="headerlink" title="class的命名"></a>class的命名</h4><p>头：header<br>内容：content/container<br>尾：footer<br>导航：nav navigation n.航行；航海<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体佈局宽度：wrapper<br>左右中：left right center<br>登录条：loginbar<br>标志：logo<br>广告：banner<br>页面主体：main<br>热点：hot<br>新闻：news<br>下载：download<br>子导航：subnav<br>菜单：menu<br>子菜单：submenu<br>搜索：search<br>友情链接：friendlink<br>页脚：footer<br>版权：copyright<br>滚动：scroll<br>内容：content<br>标签：tags<br>文章列表：list<br>提示信息：msg–message<br>小技巧：tips<br>栏目标题：title<br>加入：joinus<br>指南：guide<br>服务：service<br>注册：regsiter<br>状态：status<br>投票：vote<br>合作伙伴：partner</p><h4 id="id的命名"><a href="#id的命名" class="headerlink" title="id的命名"></a>id的命名</h4><p><strong>页面结构</strong></p><p>容器: container<br>页头：header<br>内容：content/container<br>页面主体：main<br>页尾：footer<br>导航：nav<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体佈局宽度：wrapper<br>左右中：left right center</p><p><strong>导航</strong></p><p>导航：nav<br>主导航：mainnav<br>子导航：subnav<br>顶导航：topnav<br>边导航：sidebar<br>左导航：leftsidebar<br>右导航：rightsidebar<br>菜单：menu<br>子菜单：submenu<br>标题: title<br>摘要: summary</p><p><strong>功能</strong></p><p>标志：logo<br>广告：banner<br>登陆：login<br>登录条：loginbar<br>注册：register<br>搜索：search<br>功能区：shop<br>标题：title<br>加入：joinus<br>状态：status<br>按钮：btn<br>滚动：scroll<br>标籤页：tab<br>文章列表：list<br>提示信息：msg<br>当前的: current<br>小技巧：tips<br>图标: icon<br>注释：note<br>指南：guild<br>服务：service<br>热点：hot<br>新闻：news<br>下载：download<br>投票：vote<br>合作伙伴：partner<br>友情链接：link<br>版权：copyright</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;class的命名&quot;&gt;&lt;a href=&quot;#class的命名&quot; class=&quot;headerlink&quot; title=&quot;class的命名&quot;&gt;&lt;/a&gt;class的命名&lt;/h4&gt;&lt;p&gt;头：header&lt;br&gt;内容：content/container&lt;br&gt;尾：footer&lt;b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>定位与层模型</title>
    <link href="http://yoursite.com/2018/12/09/%E5%AE%9A%E4%BD%8D%E4%B8%8E%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/12/09/定位与层模型/</id>
    <published>2018-12-09T09:16:33.000Z</published>
    <updated>2019-01-02T03:26:14.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="层模型"><a href="#层模型" class="headerlink" title="层模型"></a><font color="red">层模型</font></h2><p>css中元素的层次模型主要是由<font color="red">position</font>这个属性来决定的。</p><p>position属性：position的意思是定位，同样这个属性的作用就是<font color="red">给元素施加定位</font>。它一共有四个值，分别是<font color="red">static、absolute、relative、fixed</font>。</p><p><strong><font color="red">static</font></strong></p><p>• static是<font color="red">默认</font>的属性，当我们没有写position属性的时候，元素默认的定位就是static定位。</p><p><strong><font color="red">absolute</font></strong></p><p>• absolute是<font color="red">绝对定位</font>的意思，它会使元素<font color="red">脱离本来的位置</font>再进行定位，它会使元素像立交桥一样出现空间上的分层，当元素脱离原来的位置之后，其他的元素就会看不到这个元素。同时，<font color="red">absolute也可以触发bfc</font>。</p><p>• 同时，当我们改变定位之后，这个元素就有四个属性可以使用了，分别是<font color="red">left、right、top、bottom</font>。这四个属性分别可以设置当前元素距离左边、右边、上边和下边的距离为多少，但是四个属性很少一起出现，一般都是两两一对出现，其中left和top是一对，right和bottom是一对。</p><pre><code>div{    width: 100px;    height: 100px;    position: absolute;    left: 100px;    top: 100px;}</code></pre><p>这个div就会脱离原来的位置，然后距离浏览器上边框和左边框分别100px的距离。</p><p>• 最后一点，absolute的参照物是<font color="red">距离它最近的有定位（除了static）的父级</font>，当每一个父级都没有定位的时候，元素会相对于<font color="red">浏览器边框</font>进行定位。</p><p><strong><font color="red">relative</font></strong></p><p>• relative是<font color="red">相对定位</font>的意思，它会让元素保留原来的位置再进行定位，后面的元素可以看到它本来的位置。</p><p>• 当position改成relative之后，left、top、right、bottom进行的定位就会变成<font color="red">相对于自身的位置</font>进行移动了。</p><p>• relative的<font color="red">参照物是元素自身</font>。</p><p>• 当我们仅仅给元素设置position:relative;并没有设置left、right、top、bottom属性的时候，元素的定位是没有发生任何改变的，因为这个特性，一般在开发中，<font color="red">relative都是用作设置参照物的</font>，一个absolute元素要相对于那个元素进行移动，就给那个元素设置relative的定位就可以了。</p><font color="red">我们通过例子来看一下absolute和relative的区别。</font><br>我们现在有这样一个结构:<br><br>    <div class="wrapper"><br>        <div class="box"><br>            <div class="content"></div><br>        </div><br>    </div><br><br>    .wrapper{<br>        width: 200px;<br>        height: 200px;<br>        background-color: orange;<br>        margin-top: 100px;<br>        margin-left: 100px;<br>    }<br>    .box{<br>        width: 100px;<br>        height: 100px;<br>        background-color: black;<br>        margin-left: 100px;<br>    }<br>    .content{<br>        width: 50px;<br>        height: 50px;<br>        background-color: yellow;<br>    }<br><br>这个时候时候我们在浏览器中看到的样式是这个样子的：<br><br><img src="https://i.imgur.com/qx7jaAd.png" alt=""><br><br>现在我们给content加上定位的样式。<br><br>    .content{<br>        position: absolute;<br>        left: 50px;<br>        width: 50px;<br>        height: 50px;<br>        background-color: yellow;<br>    }<br><br>这个时候浏览器中的样式就会发生改变，content那个黄色的小方块会跑到橘黄色的方块外面：<br><br><img src="https://i.imgur.com/a6ip5NV.png" alt=""><br><br>这是因为，当我们给content设置position:absolute;之后，浏览器在渲染的时候，会先向上找到box这个div，看看这个div有没有定位，因为没有，所以继续向上找wrapper，依然没有，再向上找body，还是没有，所以最后就是<font color="red">相对于浏览器边框定位</font>，这个时候content的left属性就是相对于浏览器边框左边有50px的距离的意思。<br><br>现在我们把content的定位换成relative，浏览器中的结果变成了这个样子：<br><br><img src="https://i.imgur.com/d9fpGrk.png" alt=""><br><br>本来content黄色小方块在黑色方块的左上角，然后relative相对与自身的位置进行定位，这个时候的left属性的意思就是相对于本来在黑色左上角的那个位置向右移动了50px的距离，也就是现在这个黄色小方块所在的位置。<br><br>因此，总结一下absolute和relative的特点如下：<br><br><br>• <font color="red">absolute：<br><br>1.脱离原来位置进行定位<br><br>2.相对于最近的有定位的父级进行定位，如果没有那么相对于浏览器边框定位。</font><p>• <font color="red">relative：</font></p><font color="red">1.保留原来位置定位<br><br>2.相对于最近的有定位的父级进行定位<br><br>一般被用来设置参照物</font><p><strong><font color="red">fixed</font></strong></p><p>fixed定位是<font color="red"><strong>相对于视口</strong></font>的定位，我们在网页上都见过左右两边不随着滚轮滚动而改变位置的<font color="red">广告栏</font>，这种广告栏就是用fixed定位的。</p><pre><code>&lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt;.fixed{    position: fixed;    right: 0px;    top: 200px;    height: 200px;    width: 50px;    background-color: red;}</code></pre><p>这段代码中，div.fixed这个元素就是一直在视口的右边，不随着我们滚动而改变相对于视口的位置。</p><font color="red">最后提一点</font><p>• 值得注意的是，当我们写这样一段代码的时候：</p><pre><code>&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;.demo{    position: absolute;    margin-top: 200px;    height: 200px;    width: 50px;    background-color: red;}</code></pre><p>我们把absolute换成relative之后，会发现整个div会向上移动一小段距离，这是为什么呢？</p><p>答案其实就在上一篇的文章里，<font color="red">margin合并问题</font>——body标签本身有8px的margin，而四个方向的margin自然包括了margin-bottom，我们为div.demo设置了margin-top，就会导致margin合并的问题发生，当position是relative的时候，并没有触发bfc，所以中间的距离会取二者的最大值，也就是200px，当position是absolute的时候，因为触发了bfc效果，从而消除掉margin合并的bug，因此中间的距离是200+8=208px。</p><pre><code>我们还可以实现多栏布局了！&lt;div class=”left”&gt;&lt;/div&gt;&lt;div class=”right”&gt;&lt;/div&gt;&lt;div class=”mid”&gt;&lt;/div&gt;*{    margin: 0px;    padding: 0px;}div{    height: 100px;}.left{    position: absolute;    left: 0;    width: 100px;    background-color: yellow;}.right{    position: absolute;    right: 0;    width: 100px;    background-color: #ffc;}.mid{    margin-left: 100px;    margin-right: 100px;    background-color: #fcc;}</code></pre><p>• 要注意的是，div.mid记得<font color="red">写在后面</font>，如果写在最前面的话，因为div是block块级元素会独占一行，这样就会把左侧和右侧的div给挤到下一行了。当然我们给.left和.right都加上<font color="red">top:0px;</font>之后，这个问题也就不用考虑了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;层模型&quot;&gt;&lt;a href=&quot;#层模型&quot; class=&quot;headerlink&quot; title=&quot;层模型&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;层模型&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;css中元素的层次模型主要是由&lt;font color=&quot;red&quot;&gt;position
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>其他小知识点</title>
    <link href="http://yoursite.com/2018/12/08/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/12/08/其他知识点/</id>
    <published>2018-12-08T09:16:33.000Z</published>
    <updated>2019-01-02T02:32:00.264Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何像JQuery里面一样连续调用-return-this"><a href="#如何像JQuery里面一样连续调用-return-this" class="headerlink" title="如何像JQuery里面一样连续调用 (return this)"></a><font color="red">如何像JQuery里面一样连续调用 (return this)</font></h4><pre><code>var deng = {    smoke : function(){        console.log(&apos;Smoking...!!!&apos;);        return this;        //隐式 return undefined    },    drink : function(){        console.log(&apos;drinking...ye!&apos;);        return this;    },    perm : function(){        console.log(&apos;perming...cool!&apos;);        return this;    }}deng.smoke().drink().perm().smoke().drink();</code></pre><h4 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a><font color="red">arguments.callee</font></h4><p>指向函数自身引用</p><pre><code>//此时想用递归求阶乘 但是,函数是一个匿名函数var num = (function (n){    if(n ==1){        return 1;    }    return n * arguments.callee(n-1)}(10))</code></pre><h4 id="caller"><a href="#caller" class="headerlink" title="caller"></a><font color="red">caller</font></h4><pre><code> function test(){    demo();}function demo(){    console.log(demo.caller);}test();</code></pre><h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a><font color="red">label标签</font></h4><p>label标签的作用主要是用来<strong><font color="red">绑定</font></strong>的，它里面有一个<strong><font color="red">for属性</font></strong>。</p><p>通过for属性，里面写上要绑定的标签的id，就可以把这个label标签绑定到相对应的标签上了。</p><pre><code>&lt;label for=&quot;demo&quot;&gt;username:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;demo&quot; /&gt;</code></pre><p>现在我们点击username这个label标签，也可以触发input的聚焦事件，就好像这两个是一个东西一样，可以提高用户体验。<br>另外，我们如果在js代码中要表示label标签的for属性的话，要写<font color="red">htmlFor</font>，而不能直接写for。</p><h4 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a><font color="red">属性映射</font></h4><p>这里的映射是指标签的行间属性（特性）和DOM对象的属性之间的映射关系。</p><pre><code>&lt;div class=&quot;demo&quot; id=&quot;only&quot; data-log=&quot;123&quot; abc=&quot;a&quot;&gt;&lt;/div&gt;</code></pre><p>class和id属性是系统自带的，后两个属性是我们自己写的属性。<br>而我们获取出来的DOM对象div，可以通过div.className和div.id的方式来改写行间的属性值，但是却没法通过div.data-log或者div.abc来改写行间属性。</p><p>这是因为系统默认的属性之间是有一种映射关系的，我们可以直接修改DOM的属性来修改行间属性，但是对于我们自己设置的属性，就只能通过<font color="red">setAttribute</font>和<font color="red">getAttribute</font>来设置和获取了。</p><p>js引擎特殊赋予的映射关系有：class、id、style、value等属性。</p><h4 id="img图片预加载"><a href="#img图片预加载" class="headerlink" title="img图片预加载"></a><font color="red">img图片预加载</font></h4><p>其实图片预加载是一种<font color="red">思想</font>，而不是一种代码方式。</p><pre><code>var count = 0,    img;var timer = setInterval(function () {    count++;    if(count == 5) {        img = document.createElement(&apos;img&apos;);        img.src=&apos;xxx&apos;;        document.body.appendChild(img);        clearInterval(timer);    }}, 1000);</code></pre><p>如果我们加入的图片很大的话，展示出来的效果将是一点一点的往下加载，导致很久图片整体才会显现出来。因此，我们为了让图片显示出来的时候就是整体，只需要让图片的src提前下载，等到需要展示的时候直接加入进来就可以。</p><pre><code>var count = 0,    img = document.createElement(&apos;img&apos;);img.src = &apos;xxx&apos;;var timer = setInterval(function () {    count++;    if(count == 5) {        document.body.appendChild(img);        clearInterval(timer);    }}, 1000);</code></pre><p>但是凡事优化就会有利有弊，这种方式的<font color="red">弊端就在于前期会很占用网速</font>。</p><h4 id="模拟提取类名"><a href="#模拟提取类名" class="headerlink" title="模拟提取类名"></a><font color="red">模拟提取类名</font></h4><pre><code>Document.prototype.getClassName = function (className) {    // 获取出来所有的元素    var allEle = document.getElementsByTagName(&apos;*&apos;),            retArr = [];    // 遍历每一个元素    for (var i = 0, len = allEle.length; i &lt; len; i++) {        // 把这个元素的所有类名都提取出来        var classNameArr = [];        if (allEle[i].className) {            classNameArr = allEle[i].className.split(&apos; &apos;);            // 去除掉类名数组中的空字符串            classNameArr = classNameArr.filter(function (value, key) {                return classNameArr[key];            });        }        for (var j = 0, classlen = classNameArr.length; j &lt; classlen; j++) {            if(classNameArr[j] == className) {                retArr.push(allEle[i]);                break;            }        }    }    return retArr;}</code></pre><font color="red">getElementsByTagName(‘*’)</font>的意思是把文档中所有的标签都选择出来的意思。<br>这样我们就可以模拟jQuery的类名提取方式了。<br><br><strong> <font color="red">文档碎片documentFragment</font> </strong><br><br>这个文档碎片就是我们前面提到过nodeType区分节点时候的属性值11的那个文档碎片节点。<br><br>文档碎片可以当做<font color="red">容器</font>来进行<font color="red">效率的优化</font>。<br><br>当我们动态生成很多元素然后加入到文档的时候，因为每一次添加页面都会重新重绘重排一次，效率非常低。<br><br><font color="red">这个时候我们就可以把这些元素全部放到文档碎片里面，然后最后直接把整个文档碎片放进文档就可以了，这样页面只需要重绘重排一次即可。</font><pre><code>var fragment = document.createDocumentFragment();var div = document.createElement(&apos;div&apos;);var span = document.createElement(&apos;span&apos;);var p = document.createElement(&apos;p&apos;);fragment.appendChild(div);fragment.appendChild(span);fragment.appendChild(p);document.body.appendChild(fragment);</code></pre><p>但是论时间添加事件的话，<font color="red">文档碎片的添加速度可能会比直接添加的速度要慢</font>，这只是理论上可以节省添加时间，但是在其他方面确实存在优化效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;如何像JQuery里面一样连续调用-return-this&quot;&gt;&lt;a href=&quot;#如何像JQuery里面一样连续调用-return-this&quot; class=&quot;headerlink&quot; title=&quot;如何像JQuery里面一样连续调用 (return this)&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2018/12/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/12/07/正则表达式/</id>
    <published>2018-12-07T09:16:33.000Z</published>
    <updated>2018-12-19T10:30:58.059Z</updated>
    
    <content type="html"><![CDATA[<p><strong>正则表达式</strong></p><pre><code>var reg = /[1234567890][1234567890][1234567890]/g;var str = &quot;12309u86451akbjdakndkja&quot;;str.match(reg);// [&quot;123&quot;, &quot;864&quot;]</code></pre><p>i(ignoreCase) 忽视大小写<br>g(global) 全局匹配<br>全局属性g下一次进行查找时，在正则表达式内部有一个lastIndex来记录匹配的位置<br>m(multiline) 执行多行匹配 </p><pre><code>var str = &quot;AbCd&quot;;var reg = /abc/i;  str.match(reg);// [&quot;AbC&quot;]var reg1 = new RegExp(&quot;abc&quot;, &quot;m&quot;);</code></pre><p>匹配以a开头的字符</p><pre><code>var reg = /^a/gm;var str = &quot;abcde\na&quot;;str.match(reg);// [&quot;a&quot;, &quot;a&quot;]</code></pre><p>非a非b全局匹配</p><pre><code>var reg = /[^a][^b]/g;var str = &quot;ab1cd&quot;;str.match(reg);// [&quot;b1&quot;, &quot;cd&quot;]</code></pre><p>| 表示或 匹配该符号的左边或者右边<br>abc或bcd 0到9</p><pre><code>var reg = /(abc|bcd)[0-9]/g;var str = &quot;abc2&quot;;str.match(reg);// [&quot;abc2&quot;]</code></pre><p><strong>元字符</strong></p><pre><code>\n:换行 \r:行结束 \t:制表符 \f:换页符 \v:垂直制表符\w === [0-9A-z_]     单词字符\W === [^\w]         非单词字符\d === [0-9]         数字\D === [^\d]         非数字\s === [\t\n\r\v\f ] 空白字符\S === [^\s]         非空白字符\b === 单词边界      \B === 非单词边界.  === [^\r\n]        单个字符,除了换行和行结束符\uxxx   查找以十六进制数xxxx规定的Unicode字符</code></pre><p><strong>量词</strong>  </p><pre><code>n+       {1, 多次}n*       {0, 多次}n?       {0, 1}n{x}     {x}n{x, y}  {x, y}n{x, }   {x, }n$       以n结尾^n       以n开头?=n      后面紧接着指定字符串n的字符串?!n      后面没有紧接着指定字符串n的字符串</code></pre><p><strong>贪婪匹配</strong>:匹配字符是尽可能多的匹配，同时允许后续的表达式继续匹配。<br><strong>非贪婪匹配</strong>:加?   n+?   n*? …等</p><p>例</p><pre><code>var reg = /[\bcde\B]/g;var str = &quot;abc cdefgh&quot;;str.match(reg);// [&quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</code></pre><p>例</p><pre><code>var reg = /[\u0000-\uffff]/g;var str = &quot;老邓身体好&quot;;str.match(reg);// [&quot;老&quot;, &quot;邓&quot;, &quot;身&quot;, &quot;体&quot;, &quot;好&quot;]</code></pre><p>例</p><pre><code>var reg = /\d*/g;var str = &quot;abc&quot;;str.match(reg);// &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot;</code></pre><p>例</p><pre><code>var reg = /^abc$/g;// 以当前abc开头并且以abc结尾var str = &quot;abcabc&quot;;str.match(reg);// null</code></pre><p>如何匹配 aaaa 4个一样的?<br><strong>()子表达式</strong>  \1反向引用第一个子表达式里面的内容(即跟全面的完全相同)</p><pre><code>var reg = /(\w)\1\1\1/g;var str = &quot;aaaa&quot;;str.match(reg);// [&quot;aaaa&quot;]</code></pre><p>如何匹配 aabb?</p><pre><code>var reg = /(\w)\1(\w)\2/g;var str = &quot;aabb&quot;;str.match(reg);// [&quot;aabb&quot;]</code></pre><p>正则表达式方法 <strong>reg.exec()</strong>;<br>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</p><pre><code>var reg = /ab/g;var str = &quot;abababab&quot;;console.log(reg.exec(str));// 第一次游标指向0   加g游标下次会向后挪console.log(reg.lastIndex);// 游标</code></pre><p>字符串方法 <strong>str.search()</strong><br>用于检索字符串中指定的子字符串,或检索与正则表达式相匹配的子字符串,并返回子串的起始位置。<br>search()方法不支持全局搜索,因为会忽略正则表达式参数的标识g,并且也忽略了regexp的lastIndex属性，总是从字符串的开始位置进行检索，所以它会总是返回str的第一个匹配的位置。</p><pre><code>var str = &quot;javaScript&quot;;str.search(&quot;Script&quot;);// 4</code></pre><p><strong>replace(reg,replacement)</strong> 方法是执行查找并替换的操作。<br>它将正则表达式regexp匹配到的字串，然后用replacement的字符串替换掉字串，<br>如果有全局标识g，则替换全部匹配的字串，否则只替换第一个匹配字串。<br>使用replacement中的特殊字符替换，replacement中$字符有特殊的意义</p><pre><code>1) $1、$2 ...$99         与regexp中的第1个到99个子表达式相匹配的文本2) $&amp;                    与regexp相匹配的字串3) $`                    位于匹配子串左侧的文本4) $&apos;                    位于匹配子串右侧的文本5) $$                    直接量符号</code></pre><p>例</p><pre><code>var str = &quot;javascript&quot;;str.replace(/(java)(script)/, &apos;$2$1&apos;);// &quot;scriptjava&quot;</code></pre><p>把所有的aabb 匹配成bbaa</p><pre><code>var reg = /(\w)\1(\w)\2/g;var str = &quot;aabb&quot;;console.log(str.replace(reg, &quot;$2$2$1$1&quot;));console.log(str.replace(reg, function($, $1,$2){// $(全局) $1(子表达式1) $2(子表达式2)    return $2+$2+$1+$1;}));</code></pre><p>the-first-name 匹配成小驼峰式</p><pre><code>var reg = /-(\w)/g;var str = &quot;the-first-name&quot;;console.log(str.replace(reg, function($, $1){    return $1.toUpperCase();}));</code></pre><p>正向预查 正向断言</p><pre><code>var str = &quot;abaaaaa&quot;;var reg = /a(?=b)/g;// 后面跟着b的a</code></pre><p>将10000000以10.000.000的形式匹配</p><pre><code>var str = &quot;100000000&quot;;var reg = /(?=(\B\d{3})+$)/g;console.log( str.replace(reg, &quot;.&quot;));</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;正则表达式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var reg = /[1234567890][1234567890][1234567890]/g;
var str = &amp;quot;12309u86451akbjdakndkja&amp;quot;;
s
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异步加载JS</title>
    <link href="http://yoursite.com/2018/12/06/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDJS/"/>
    <id>http://yoursite.com/2018/12/06/异步加载JS/</id>
    <published>2018-12-06T09:16:33.000Z</published>
    <updated>2018-12-25T02:24:35.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先介绍一下JSON"><a href="#先介绍一下JSON" class="headerlink" title="先介绍一下JSON"></a><font color="red">先介绍一下JSON</font></h2><p>我们传输数据就两种格式：<font color="red">xml和json</font>。</p><p>xml是以<font color="red">html</font>为模板，自定义标签名作为数据名来传递数据，书写起来很麻烦，现在多用json，很少使用xml。</p><p>json是传输数据的另一种格式，它是以<font color="red">对象</font>为模板（本质上就是对象，但是用途有所区别，对象是本地使用，json是用来传输数据）。</p><p>不过我们传输数据的时候并不能将一个json对象直接传过去，我们只能传过去json形式的字符串，这个时候我们就需要用到JSON上的两个方法了。</p><font color="red">JSON.parse() —&gt; string-&gt;json</font><font color="red">JSON.stringify() —&gt; json-&gt;string</font><p>通过JSON上的这两个方法，我们就可以进行数据传输了。</p><pre><code>var obj = {    &quot;name&quot; : &quot;abc&quot;,    &quot;age&quot; : 123}// 将json转换为字符串 传给后端var str = JSON.stringify(obj);// 将后端传过来的json字符串转换为json对象var str1 = JSON.parse(str);</code></pre><p>• 我们的页面有三个树：DOMTree、CSSTree、renderTree。（实际上多于三个），renderTree上有两个规则：repaint和reflow，重绘和重排。</p><p>repaint是元素自身的位置和宽高不变，只改变颜色的之类的属性而不会导致后面的元素位置的变化的时候，renderTree发生的动作。</p><p>reflow是元素自身的位置或者宽高改变了从而导致的整个页面的大范围移动的时候，renderTree发生的动作。</p><p>所以我们在DOM操作的时候，要<font color="red">尽量避免重排</font>。</p><h2 id="JS异步加载部分"><a href="#JS异步加载部分" class="headerlink" title="JS异步加载部分"></a><font color="red">JS异步加载部分</font></h2><p>我们前面知道script标签的特点是会阻塞后面的DOM解析，只有当script标签下载完成并且全部执行完之后，浏览器才会继续解析DOM。</p><p>这样就导致了js加载有这样的缺点：加载工具方法本身没有必要阻塞文档，js加载会影响整个页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染。</p><p>DOMTree就是解析DOM结构的，当我们在解析DOM的时候突然碰到一个script标签，那么这个script标签就会阻断DOMTree和CSSTree，然而我们有一些js的工具库并不操作DOM，这个时候我们就需要让这些工具库进行异步加载或者按需加载了。</p><p>以前有一种写法是将script标签写在body的最后面，等在DOM全部解析完成之后才加载js。</p><p>现在有了html5标准之后，就有了另一套异步加载js的方法了。</p><p>js异步加载的三种方案：</p><p>1.<font color="red"><strong>defer</strong></font>异步加载</p><p>我们在script标签的行间写一个defer=”defer”或者直接写defer，就可以让这个script变成异步加载了。但是这种异步只是针对下载方面，<font color="red"><strong>只有等DOMTree全部解析完成（不包括下载完里面的资源）后才会异步执行</strong></font>。而且这个方法<font color="red">只有IE和一些高版本的firefox和chrome可以用</font>。</p><pre><code>&lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot;&gt;    console.log(&apos;hello&apos;);&lt;/script&gt;</code></pre><p>不过这一种方式<font color="red">可以在script标签里面写代码</font>。</p><p>注意：IE6和IE7的异步加载最多只能有2个，当多余两个的时候必须等前两个加载完才会加载第三个。</p><p>所有defer的js代码都<font color="red">保证按照顺序执行</font>。</p><p>2.async异步加载</p><p>async是<font color="red"><strong>asynchronous</strong></font>的缩写，它是html5的标准，<font color="red"><strong>下载完成之后就会立即异步执行</strong></font>，这种方法<font color="red">除了IE6-IE8其他的浏览器都好用</font>。</p><pre><code>&lt;script type=&quot;text/javascript&quot; async=&quot;async&quot;&gt;&lt;/script&gt;</code></pre><p>不过这种方式<font color="red">不能把代码写在script标签里面</font>，只能引用。（虽然标准是这么写的，但是现在随着内核升级，async里面也可以写代码了，在没有src的情况下）。</p><p>而且async的js代码<font color="red">不能保证是顺序执行的</font>。</p><p>• 这两个属性<font color="red">不能一起使用</font>！</p><p>兼容性写法：</p><p>1.<strong>直接写两个script标签，一个是defer，一个是async</strong>。</p><p>但是这种方法有缺陷：IE高版本会加载两遍引起冲突，有些浏览器两个都没有会一个都加载不出来。</p><p>所以我们就需要用第二种方法了。</p><p>2.<strong>通过动态添加script标签</strong>。</p><p>“Script-inserted script elements now have async default to true, which can be set to false to make the scripts execute in insertion order.”</p><p>w3c的标准规定：<font color="red">动态添加的script标签是异步的</font>。</p><p>通过这个特性，我们这里就可以封装一个兼容性的异步加载js的函数了。</p><pre><code>function loadScript(url, callback){    var script = document.createElement(&apos;script&apos;);    script.type = &quot;text/javascript&quot;;         // 如果网速够快 url在瞬间下载完毕 而readyState瞬间在最终状态      // 所以onreadystatechange这个事件不可能在触发    // 即绑定事件之前绑定就已经完事了,此时绑定没有任何意义了 所以把src加载放在绑定事件之后    if(script.readyState){// 兼容性:仅IE        script.onreadystatechange = function(){            if(script.readyState == &quot;complete&quot; || script.readyState == &quot;loaded&quot;){                tools[callback]();            }        }    }else{// 兼容性:Safari chrome firefox opera        script.onload = function(){            tools[callback]();        }    }    script.src = url;// 下载    // 当把标签添加到页面的时候才会执行这个脚本(否则只是下载完)    document.head.appendChild(script);}loadScript(&apos;demo.js&apos;, &quot;test&quot;);</code></pre><p>或者如下调用</p><pre><code>loadScript(&apos;demo.js&apos;, function(){     test();})</code></pre><p>但是不能写成 </p><pre><code>loadScript(&apos;demo.js&apos;, test);// test is not defined</code></pre><p>• 异步加载js<font color="red"><strong>不允许使用document.write</strong></font>这个方法。它会清除文档流，一旦执行就会把全部的标签都清除掉，包括自身的script标签。</p><h2 id="JS加载时间线（performace-timing-line）"><a href="#JS加载时间线（performace-timing-line）" class="headerlink" title="JS加载时间线（performace timing line）"></a><font color="red">JS加载时间线（performace timing line）</font></h2><p>1、创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。</p><p>2、遇到link外部css，创建线程加载，并继续解析文档。</p><p>3、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。</p><p>4、遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。 对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()）</p><p>5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</p><p>6、当文档解析完成，document.readyState = ‘interactive’。</p><p>7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,</p><p>但同样禁止使用document.write()）;</p><p>8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，</p><p>转化为事件驱动阶段。</p><p>9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window</p><p>对象触发load事件。</p><p>10、从此，以异步响应方式处理用户输入、网络事件等。</p><p>JS的时间线是非常重要的知识点，希望大家能背下来这一块哟~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;先介绍一下JSON&quot;&gt;&lt;a href=&quot;#先介绍一下JSON&quot; class=&quot;headerlink&quot; title=&quot;先介绍一下JSON&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;先介绍一下JSON&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;我们传输数据就两种格式：&lt;font
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件处理模型与事件委托</title>
    <link href="http://yoursite.com/2018/12/05/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>http://yoursite.com/2018/12/05/事件处理模型与事件委托/</id>
    <published>2018-12-05T09:16:33.000Z</published>
    <updated>2018-12-25T02:28:04.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件处理模型——事件冒泡、事件捕获"><a href="#事件处理模型——事件冒泡、事件捕获" class="headerlink" title="事件处理模型——事件冒泡、事件捕获"></a><font color="red">事件处理模型——事件冒泡、事件捕获</font></h2><p>上一篇介绍了事件的绑定，我们这里先写一个三层div嵌套的结构并且给每一个div都加一个点击事件。</p><pre><code>.wrapper{    width: 200px;    height: 200px;    background-color: red;}.box{    width: 100px;    height: 100px;    background-color: green;}.content{    width: 50px;    height: 50px;    background-color: black;}var wrapper = document.getElementsByClassName(&apos;wrapper&apos;)[0],        box = document.getElementsByClassName(&apos;box&apos;)[0],    content = document.getElementsByClassName(&apos;content&apos;)[0];wrapper.onclick = function () {  console.log(&apos;wrapper&apos;);}box.onclick = function () {  console.log(&apos;box&apos;);}content.onclick = function () {  console.log(&apos;content&apos;);}</code></pre><p>• 现在我们点击最外层的wrapper，控制台打印的wrapper。</p><p>• 点击box，却打印出来box和wrapper</p><p>• 点击content打印出来content、box、wrapper</p><p>这个现象就是我们所说的事件冒泡。</p><p><strong>事件冒泡</strong>：在<font color="red">结构上</font>（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，<font color="red">子元素冒泡向父元素</font>，结构上的自底向上。（这里的底是结构上的底，视觉上是自顶向下）</p><p>大部分事件都有事件冒泡现象，并且<font color="red">所有的浏览器都有事件冒泡</font>。</p><p>结构上的冒泡，和视觉的位置没有关系，我们看一下三个方块视觉上分开的例子：</p><pre><code>.wrapper{        width: 200px;        height: 200px;        background-color: red;        position: absolute;    }    .box{        width: 100px;        height: 100px;        background-color: green;        position: absolute;        left: 200px;        top: 200px;    }    .content{        width: 50px;        height: 50px;        background-color: black;        position: absolute;        left: 100px;        top: 100px;    }</code></pre><p>我们点击content部分之后依然会把box和wrapper都打印出来。</p><p><font color="red">并不是所有的事件都有冒泡</font>，focus、blur、change、submit、reset、select等方法就没有事件冒泡现象。</p><p><strong>事件捕获</strong>：<font color="red">结构上</font>（非视觉上）嵌套关系的元素，会存在事件捕获功能，即同一事件，<font color="red">自父元素捕获至子元素</font>（事件源元素），结构上的自顶向下。</p><p><strong>addEventListener最后一个参数就是是否开始事件捕获</strong>，当我们填true的时候，就代表开启了事件捕获。只要开启了事件捕获，就不会冒泡了，如果不捕获的话，就遵循事件冒泡。</p><p>因为addEventListener只有chrome有，因此<font color="red">事件捕获也只有chrome浏览器有</font>。</p><p>依然是上面的那个例子：</p><pre><code>var wrapper = document.getElementsByClassName(&apos;wrapper&apos;)[0],    box = document.getElementsByClassName(&apos;box&apos;)[0],    content = document.getElementsByClassName(&apos;content&apos;)[0];wrapper.addEventListener(&apos;click&apos;, function (e) {    console.log(&apos;wrapper&apos;);}, true);box.addEventListener(&apos;click&apos;, function (e) {    console.log(&apos;box&apos;);}, true);content.addEventListener(&apos;click&apos;, function (e) {    console.log(&apos;content&apos;);}, true);</code></pre><p>现在点击content之后，顺序是wrapper、box、content。</p><p>当事件冒泡和事件捕获同时存在的时候，事件冒泡和事件捕获的触发顺序则为：<strong><font color="red">先捕获，再冒泡</font></strong>。</p><pre><code>var wrapper = document.getElementsByClassName(&apos;wrapper&apos;)[0],        box = document.getElementsByClassName(&apos;box&apos;)[0],    content = document.getElementsByClassName(&apos;content&apos;)[0];wrapper.onclick = function () {  console.log(&apos;wrapperBubbler&apos;);}box.onclick = function () {  console.log(&apos;boxBubbler&apos;);}content.onclick = function () {  console.log(&apos;contentBubbler&apos;);} wrapper.addEventListener(&apos;click&apos;, function (e) {    console.log(&apos;wrapper&apos;);}, true);box.addEventListener(&apos;click&apos;, function (e) {    console.log(&apos;box&apos;);}, true);content.addEventListener(&apos;click&apos;, function (e) {    console.log(&apos;content&apos;);}, true);</code></pre><p>结果是先捕获再冒泡。</p><p>但是当我们把捕获写到冒泡前面的时候，顺序好像发生了变化。</p><p>wrapper–&gt;box–&gt;<font color="red">contentBubble</font>–&gt;content–&gt;boxBubble–&gt;wrapperBubble</p><p>这里是因为点击content，并不属于冒泡，而是属于<font color="red">事件执行</font>，我们先绑定的boxBubble，所以就先捕获，再事件执行，再冒泡，这与我们的结论没有冲突。</p><h2 id="取消冒泡和阻止默认事件"><a href="#取消冒泡和阻止默认事件" class="headerlink" title="取消冒泡和阻止默认事件"></a><font color="red">取消冒泡和阻止默认事件</font></h2><p>• 有时候冒泡或者默认事件会对我们的功能造成影响，因此我们需要适时地取消冒泡和默认事件。</p><p>• 我们绑定事件的处理函数的时候，可以传递一个形参，代表我们的事件对象，一般是e或者event，<font color="red">系统会自动帮我们捕获事件源对象并且把事件源对象传入</font>。</p><p><strong><font color="red">取消冒泡的方法</font></strong></p><p>1.<strong><font color="red">w3c标准方法：event.stopPropagation()</font></strong></p><pre><code>var wrapper = document.getElementsByClassName(&apos;wrapper&apos;)[0],        box = document.getElementsByClassName(&apos;box&apos;)[0],    content = document.getElementsByClassName(&apos;content&apos;)[0];content.onclick = function (e) {    console.log(&apos;content&apos;);    e.stopPropagation();}</code></pre><p><strong>IE9以及以下的版本不支持这个方法。</strong></p><p>2.<strong><font color="red">event.cancelBubble = true</font></strong></p><p>这个属性是IE的，不过一些高版本的浏览器也有这个属性，只要让这个属性的值等于true，同样也可以取消事件冒泡。</p><p>封装一个兼容性的取消事件冒泡的方法：</p><pre><code>function stopBubble(event){    if(event.stopPropagation){        event.stopPropagation();    }else{        event.cancelBubble = true;    }}</code></pre><p><strong><font color="red">默认事件</font></strong></p><p>当我们在浏览器中点击右键，会弹出一个菜单，这就是一个默认事件contextmenu。还有a标签，即使我们不写跳转的页面，也会自动刷新页面，这也是一个默认事件。<br>默认事件有好的也有不好的，这就需要我们把不需要的默认事件阻止掉。</p><p><strong><font color="red">阻止默认事件</font></strong></p><p>1.<strong><font color="red">return false</font></strong><br>不过要注意的是，这种写法只能用在句柄方式绑定的事件上。</p><pre><code>document.oncontextmenu = function () {    console.log(&apos;menu&apos;);    return false;}</code></pre><p>2.<strong><font color="red">event.preventDefault()</font></strong><br>这是w3c标准的阻止默认事件的方法，句柄也同样可以使用。不过IE9以下不兼容。</p><pre><code>documet.addEventListener(&apos;contextmenu&apos;, function (e) {    console.log(&apos;menu&apos;);    e.preventDefault();},false);</code></pre><p>3.<strong><font color="red">event.returnValue = false</font></strong><br>这个是IE的方法，事件源对象上的属性returnValue代表是否有默认事件，直接返回false就可以阻止默认事件了。</p><pre><code>document.attachEvent(&apos;oncontextmenu&apos;, function (e) {    e.returnValue = false;});</code></pre><p>现在我们也可以封装一个兼容性的阻止默认事件的方法了：</p><pre><code>function cancelHandler(event){    if(event.preventDefault){        event.preventDefault();    }else{        event.returnValue = false;    }}</code></pre><p>小例子: 阻止a标签不跳转</p><pre><code>var a = document.links[0];a.addEventListener(&apos;click&apos;, funciton (e) {    e.cancelHandler(e);},false);</code></pre><p>同时我们还可以用a标签的第四个用处，协议限定符来阻止默认事件。</p><pre><code>&lt;a href=&quot;javascript: void(0); &quot;&gt;www.baidu.com&lt;/a&gt;</code></pre><p>不仅仅是0，只要填写一个代表false的值，就可以取消掉默认事件。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a><font color="red">事件对象</font></h2><p><font color="red">在IE中，系统不会把事件对象传到方法中，因此我们的参数e或者event在IE中是不好用的，IE会把事件对象传递到window.event上</font>，所以当我们使用事件对象的时候，就要写兼容性的写法：</p><pre><code>var event = e || window.event;</code></pre><p><font color="red"><strong>event.target</strong></font> 是<font color="red">火狐</font>的获取事件源对象</p><p><font color="red"><strong>event.srcElement</strong></font> 是<font color="red">IE</font>的获取事件源对象</p><p>chrome两种都有</p><p>因此我们在获取事件源对象的时候也需要写兼容性写法</p><pre><code>wrapper.onclik = function(e){    var event = e || window.event;    var target = event.target || event.srcElement;    console.log(target);}</code></pre><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a><font color="red">事件委托</font></h2><p>我们现在有一个ul，下面有十万个li，当我们给父级的ul添加第一个点击事件之后，由于<font color="red">事件冒泡</font>的存在，不论我们点击哪一个li都会调用父级的点击事件处理函数，这个时候触发父级ul的点击函数的那个li就被称之为事件源对象。</p><p>我们<font color="red">利用事件源对象和事件冒泡来处理的方式就叫做事件委托</font>。</p><pre><code>&lt;ul&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;    &lt;li&gt;5&lt;/li&gt;    &lt;li&gt;6&lt;/li&gt;    &lt;li&gt;7&lt;/li&gt;    &lt;li&gt;8&lt;/li&gt;    &lt;li&gt;9&lt;/li&gt;    &lt;li&gt;10&lt;/li&gt;    &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;// 此处不选中li而是选中父级的ul 因为li会冒泡给ul 然后根据事件源对象找到该livar ul = document.getElementsByTagName(&apos;ul&apos;)[0];ul.onclick = function(e){    var event = e || window.event;    var target = event.target || event.srcElement;    console.log(target.innerText);}&lt;/script&gt;</code></pre><p>事件委托的<font color="red">优点</font>：</p><ol><li><font color="red">性能</font> 不需要循环所有的元素一个个绑定事件</li><li><font color="red">灵活</font> 当有新的子元素时不需要重新绑定事件</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事件处理模型——事件冒泡、事件捕获&quot;&gt;&lt;a href=&quot;#事件处理模型——事件冒泡、事件捕获&quot; class=&quot;headerlink&quot; title=&quot;事件处理模型——事件冒泡、事件捕获&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;事件处理模型——事件冒泡、事件捕获
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件绑定</title>
    <link href="http://yoursite.com/2018/12/04/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/12/04/事件绑定/</id>
    <published>2018-12-04T09:16:33.000Z</published>
    <updated>2018-12-25T02:28:24.309Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color="red">绑定事件</font></strong></p><p>1.<strong><font color="red">div.onclick(句柄方式)</font></strong> </p><p>虽然句柄方式的兼容性很好，但是一个元素的一种事件只能绑定一个函数。</p><pre><code>div.onclick = function(){    console.log(&apos;a&apos;);}</code></pre><p>2.<strong><font color="red">div.addEventListener(‘事件类型’, 处理函数, false)</font></strong></p><p>可以给一个事件绑定多个处理函数</p><pre><code>div.addEventListener(&apos;click&apos;, function(){    console.log(&apos;a&apos;);}, false);div.addEventListener(&apos;click&apos;, function(){    console.log(&apos;b&apos;);}, false);</code></pre><p>3.<strong><font color="red">div.attachEvent(‘onclick’, function(){})</font></strong></p><p>这个方法是IE独有的方法，一个事件同样可以绑定多个处理函数。</p><pre><code>div.attachEvent(&apos;onclick&apos;, function (){      console.log(&apos;a&apos;);});</code></pre><p>基本和addEventListener差不多，但是有一点区别是，<font color="red">当同一个函数绑定多次的时候，addEventListener是只执行一次，但是attachEvent会绑定几次执行几次</font>。</p><pre><code>function test () {        console.log(&apos;a&apos;);}div.attachEvent(&apos;onclick&apos;, test);div.attachEvent(&apos;onclick&apos;, test);</code></pre><p>现在点击一次会打印两个a。</p><p>封装兼容性的 事件处理函数 </p><pre><code>function addEvent(elem, type, handle){    if(elem.addEventListener){        elem.addEventListener(type, handle, false);    }else if(elem.attachEvent){        elem.attachEvent(&apos;on&apos;+type, function(){            handle.call(elem);        })    }else{        elem[&apos;on&apos;+type] = handle;    }}</code></pre><p>例: 使用原生js，addEventListener，为每一个li绑定一个点击事件，输出他们的顺序。这里就要注意这个题考察的不仅仅是绑定事件，更多的是<font color="red">闭包</font>的运用。</p><pre><code>&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;li&gt;d&lt;/li&gt;&lt;script&gt;    var li = document.getElementsByTagName(&apos;li&apos;);        for(var i = 0;i &lt; li.length;i++){            // 绑定事件 一但事件出现在循环里面要考虑是否出现闭包             (function(i){// 用立即执行函数解决                li[i].addEventListener(&apos;click&apos;, function(){                    console.log(i);                }, false);            }(i))        }&lt;/script&gt;</code></pre><p><strong><font color="red">事件处理程序的运行环境</font></strong></p><p>1.句柄绑定方式中，函数里面的<font color="red">this指向元素本身</font>。</p><p>2.addEventListener方式中，函数里面的<font color="red">this也是指向元素本身</font>。</p><p>3.attachEvent中，函数里面的<font color="red">this指向的是window而不是元素本身</font>，这算是IE的一个BUG。针对这种情况，我们就需要把函数提取出来，然后在attachEvent的时候用<font color="red">call</font>来改变函数内部this的指向。</p><pre><code>div.attachEvent(&apos;onclick&apos;, function () {       test.call(div);}, false);</code></pre><p><strong><font color="red">解除事件</font></strong></p><p>1.<strong><font color="red">ele.onclick = false/‘’/null;</font></strong></p><pre><code>var div = document.getElementsByTagName(&apos;div&apos;)[0];div.onclick = function(){    console,log(&apos;a&apos;);    this.onclick = null;}</code></pre><p>2.<strong><font color="red">ele.removeEventListener(type, fn, false);</font></strong></p><p>针对的addEventListener的解除绑定。<br>但是这里要注意，只有命名函数才可以解除绑定，当绑定的函数是匿名函数的时候，是没有办法解除绑定的。</p><pre><code>div.addEventListener(&apos;click&apos;, test, false);function test(){    console.log(&apos;a&apos;);}div.removeEventListener(&apos;click&apos;, test, false);</code></pre><p>3.<strong><font color="red">ele.detachEvent(‘on’ + type, fn);</font></strong></p><p>针对IE的attachEvent的解除绑定。也是同一个函数才可以解除绑定，匿名函数无法解除绑定。</p><p>封装兼容性的解除绑定函数：</p><pre><code>function remvoeEvent(ele, type, handle) {    if(ele.removeEventListener) {          ele.removeEventListener(type, handle, false);    }else if (ele.detachEvent) {          ele.detachEvent(&apos;on&apos; + type, handle);    }else {          ele[&apos;on&apos; + type] = null;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;绑定事件&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;div.onclick(句柄方式)&lt;/font&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;虽然句柄方式的兼容性很好，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件分类</title>
    <link href="http://yoursite.com/2018/12/03/%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/12/03/事件分类/</id>
    <published>2018-12-03T09:16:33.000Z</published>
    <updated>2018-12-25T02:26:43.761Z</updated>
    
    <content type="html"><![CDATA[<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a><font color="red">鼠标事件</font></h4><p>click、contextmenu(右键菜单)、mouseover、mouseout、mousedown、mousemove、mouseup移动端对应的(touchstart、touchmove、touchend)</p><p>• 所有的鼠标事件都有clientX和clientY，代表的是鼠标点击的位置，我们可以通过e.clientX和e.clentY来查看。</p><p>• 左键点击的顺序是：mousedown、mouseup、click</p><p>• 当我们同时绑定了click事件和mousedown事件后，如何解决mousedown和click的冲突问题？</p><pre><code>var firstTime = 0;var laseTime = 0;var key = false;document.onmousedown = function(){    firstTime = new Date().getTime();}    document.onmouseup = function(){    laseTime = new Date().getTime();    if(laseTime - firstTime &lt; 300){        key = true;    }}document.onclikc = function(){    if(key){        console.log(&apos;click&apos;);        key = false;    }}</code></pre><p>click事件永远都是左键，有左键和右键的区别的是mousedown事件。</p><p>再mousedown的事件对象中有一个属性叫做button，这个属性的值是0的时候代表我们按下的是左键，1的时候代表按下的中键，2的时候代表按下的是右键。</p><pre><code>document.onmousedown = function (e) {  if (e.button == 0) {      console.log(&apos;left&apos;);  }else if (e.button == 1) {      console.log(&apos;mid&apos;);  }else {      console.log(&apos;right&apos;);  }}</code></pre><p>这里我们就可以重新回顾一下拖拽事件了：</p><pre><code>var div = document.getElementsByTagName(&apos;div&apos;)[0]function drag(elem){    var disX,        disY;    addEvent(elem, &apos;mousedown&apos;, function(e){// 之前封装的事件绑定函数        var event = e || window.event;        disX = event.clientX - parseInt(getStyle(elem, &apos;left&apos;));// 之前封装的查询元素样式函数        disY = event.clientY - parseInt(getStyle(elem, &apos;top&apos;));        addEvent(document, &apos;mousemove&apos;, mouseMove);        addEvent(document, &apos;mouseup&apos;, mouseUp);        stopBubble(e);        cancelHandler(e);    });    function mouseMove(e){        var event = e || window.event;        elem.style.left = event.clientX - disX + &quot;px&quot;;        elem.style.top = event.clientY - disY + &quot;px&quot;;    }    function mouseUp(e){        var event = e || window.event;        removeEvent(document, &apos;mousemove&apos;, mouseMove);        removeEvent(document, &apos;mouseup&apos;, mouseUp);       }}</code></pre><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a><font color="red">键盘事件</font></h4><p>键盘事件主要有三个：keydown、keypress、keyup。<br>触发顺序分别是keydown &gt; keypress &gt; keyup。</p><p>keypress的范围和keydown有所区别：</p><p>keydown可以响应任意键盘按键，keypress只能响应字符类按键，也就是有ASCII码的字符的按键，像字母数字回车空格之类的。</p><p>事件对象的属性方面：只有keypress有charCode属性，这个属性代表的我们输入的这个字符的ASCII码，配合SHIFT之类的按键可以直接获取大写字母等。</p><p>keyCode和which每个方法都有，表示的是这个键的唯一标示，可以告诉浏览器我们按下的是键盘上的哪一个键，比如空格是32，32就代表空格。不过我们一般都用which，keyCode用的较少。</p><p>• String上有一个方法叫做fromCharCode，可以接受一个Unicode值（包含ASCII值），然后返回对应的字符串，我们可以配合这个方法和charCode来直接获取输入的字符。</p><pre><code>document.onkeypress = function(e){    console.log(String.fromCharCode(e.charCode));}</code></pre><h4 id="文本操作事件"><a href="#文本操作事件" class="headerlink" title="文本操作事件"></a><font color="red">文本操作事件</font></h4><p>input,focus,blur,change</p><pre><code>&lt;input type=&quot;text&quot; value=&quot;请输入用户名&quot; style=&quot;color: #999;position: absolute;top: 200px&quot;onfocus=&quot;if(this.value==&apos;请输入用户名&apos;){this.value=&apos;&apos;;this.style.color=&apos;#424242&apos;}&quot;onblur=&quot;if(this.value==&apos;&apos;){this.value=&apos;请输入用户名&apos;;this.style.color=&apos;#999&apos;}&quot;&gt;</code></pre><h4 id="窗体操作类-window上的事件"><a href="#窗体操作类-window上的事件" class="headerlink" title="窗体操作类(window上的事件)"></a><font color="red">窗体操作类(window上的事件)</font></h4><p><strong><font color="red">load事件</font></strong></p><p>这个事件window.onload和在body标签上写onload是一样的效果，作用是等页面中所有的东西都下载完成再执行里面的代码。</p><p><strong><font color="red">scroll事件</font></strong></p><p>这个方法是监听滚轮滚动的事件，我们可以用这个事件来写一个兼容版的fix定位。</p><pre><code>function beFixed(ele){  var initPosX = ele.getPosition().w,      initPosY = ele.getPosition().h;  addEvent(window, &apos;scroll&apos;, function(e){      ele.style.top =  initPosY + getScrollOffset().h + &apos;px&apos;;      ele.style.left =  initPosX + getScrollOffset().w + &apos;px&apos;;  })}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;鼠标事件&quot;&gt;&lt;a href=&quot;#鼠标事件&quot; class=&quot;headerlink&quot; title=&quot;鼠标事件&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;鼠标事件&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;click、contextmenu(右键菜单)、mouseover、mou
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>脚本化CSS</title>
    <link href="http://yoursite.com/2018/12/02/%E8%84%9A%E6%9C%AC%E5%8C%96CSS/"/>
    <id>http://yoursite.com/2018/12/02/脚本化CSS/</id>
    <published>2018-12-02T09:16:33.000Z</published>
    <updated>2018-12-25T02:29:42.858Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color="red">读写元素css属性</font></strong></p><p>每一个dom元素都有一个属性style，dom.style里面存放的这个元素的行间样式，我们可以通过这个属性来读写元素的行间样式。</p><p>1.碰到float这样的关键字属性的时候，前面要加一个css前缀。<font color="red">float — &gt; cssFloat</font></p><p>2.复合属性必须拆解，组合单词变成小驼峰式写法，写入的值必须是字符串格式.如</p><p>border: 1px solid red;只能写border-width、border-color、border-style。<br>background-color —&gt; backgroundColor;</p><p><strong><font color="red">查询计算样式</font></strong></p><pre><code>window.getComputedStyle(ele, null);</code></pre><p>这个方法有两个参数，第一个参数是我们要获取的元素。<br>第二个参数是一个字符串，代表我们是否要获取这个元素上面的某一个伪元素，如果不的话，就填写null，否则就填写要获取的这个元素的哪一个伪元素。</p><p>这里的样式是<font color="red">取优先级最高的(即最终展示样式)</font>，不只是行间样式，所有的只要是表现出来的样式都可以获取出来。<br>同时，返回的计算样式的值都是<font color="red">绝对值</font>，没有相对单位。IE8 及 IE8以下不兼容</p><pre><code>div:after{    width: 100px;    height; 100px;    background-color: red;}window.getComputedStyle(div, &apos;after&apos;).width;// 100px</code></pre><p>IE8有一个特殊的查询样式<font color="red">ele.currentStyle</font>。</p><p>计算样式只读，IE独有的属性，返回的计算样式的值不是经过转换的绝对值</p><p>封装兼容性方法getStyle(obj,prop);</p><pre><code>function getStyle(obj, prop){    if(window.getComputedStyle){        return window.getComputedStyle(obj, null)[prop];    }else{        return obj.currentStyle[prop];    }}</code></pre><p>例1: 我们可以写一个小方块运动的函数</p><pre><code>var div = document.createElement(&apos;div&apos;);document.body.appendChild(div);div.style.width = &quot;100px&quot;;div.style.height = &quot;100px&quot;;div.style.backgroundColor = &quot;blue&quot;;div.style.position = &quot;absolute&quot;;div.style.left = &quot;0&quot;;div.style.top = &quot;0&quot;;var speed = 1;var time = setInterval(function(){    speed += speed/20;    div.style.left = parseInt(div.style.left) + speed +&quot;px&quot;;    div.style.top = parseInt(div.style.top) + speed +&quot;px&quot;;    if(parseInt(div.style.left)&gt;200&amp;&amp;parseInt(div.style.top)&gt;200){        clearInterval(time);    }}, 50)</code></pre><p>例2: 利用计数器变量 实现状态变换</p><pre><code>&lt;div&gt;&lt;/div&gt;&lt;script&gt;    var div = document.getElementsByTagName(&apos;div&apos;)[0];    div.style.width = &quot;100px&quot;;    div.style.height = &quot;100px&quot;;    div.style.backgroundColor = &quot;red&quot;;    var count = 0;    div.onclick = function(){        count ++;        if(count % 2 ==1){            this.style.backgroundColor = &quot;green&quot;;        }else{            this.style.backgroundColor = &quot;red&quot;;        }    }&lt;/script&gt;</code></pre><p>例3: 实现用键盘控制小方块</p><pre><code>var div = document.createElement(&quot;div&quot;);document.body.appendChild(div);div.style.width = &quot;100px&quot;;div.style.height = &quot;100px&quot;;div.style.backgroundColor = &quot;green&quot;;div.style.position = &quot;absolute&quot;;div.style.left = &quot;0&quot;;div.style.top = &quot;0&quot;;document.onkeydown = function(e) {  switch (e.which) {    case 38:      div.style.top = parseInt(div.style.top) - 5 + &quot;px&quot;;      break;    case 40:      div.style.top = parseInt(div.style.top) + 5 + &quot;px&quot;;      break;    case 37:      div.style.left = parseInt(div.style.left) - 5 + &quot;px&quot;;      break;    case 39:      div.style.left = parseInt(div.style.left) + 5 + &quot;px&quot;;      break;  }};</code></pre><p>例4: 实现鼠标点击切换不同图片</p><pre><code>&lt;style&gt;    .content{        display: none;        width: 200px;        height: 200px;        border: 2px solid red;    }    .active{        background-color: yellow;    }&lt;/style&gt;&lt;div class=&quot;wrapper&quot;&gt;    &lt;button class=&quot;active&quot;&gt; 1 &lt;/button&gt;    &lt;button&gt; 2 &lt;/button&gt;    &lt;button&gt; 3 &lt;/button&gt;    &lt;div class=&quot;content&quot; style=&quot;display: block;&quot;&gt;one&lt;/div&gt;    &lt;div class=&quot;content&quot;&gt;two&lt;/div&gt;    &lt;div class=&quot;content&quot;&gt;three&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var btn = document.getElementsByTagName(&apos;button&apos;);    var div = document.getElementsByClassName(&apos;content&apos;);    for(var i = 0; i &lt; btn.length; i++){        (function(n){ //循环里面绑定事件要考虑闭包。 解决方法:立即执行函数            btn[n].onclick = function (){                for(var j = 0; j &lt; btn.length; j++){                    btn[j].className = &quot;&quot;;                    div[j].style.display = &quot;none&quot;;                }                this.className = &quot;active&quot;;                div[n].style.display = &quot;block&quot;;            }        }(i))       }&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;读写元素css属性&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个dom元素都有一个属性style，dom.style里面存放的这个元素的行间样式，我们可以通过这个属性来读写元素的行间样式。&lt;/p&gt;
&lt;p&gt;1.碰到f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>滚动条与元素尺寸</title>
    <link href="http://yoursite.com/2018/12/01/%E6%BB%9A%E5%8A%A8%E6%9D%A1%E4%B8%8E%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8/"/>
    <id>http://yoursite.com/2018/12/01/滚动条与元素尺寸/</id>
    <published>2018-12-01T09:16:33.000Z</published>
    <updated>2018-12-19T07:07:13.387Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查看滚动条的滚动距离"><a href="#查看滚动条的滚动距离" class="headerlink" title="查看滚动条的滚动距离"></a><font color="red">查看滚动条的滚动距离</font></h4><p>js中有两套方法可以查看当前滚动条的滚动距离。</p><p>1.<strong>window.pageXOffset/window.pageYOffset</strong></p><p>这个方法可以查看滚动条的横轴和纵轴的滚动距离，但是很遗憾的是IE8以及以下的版本不兼容。用以下两种</p><p>2.<strong>document.body.scrollLeft/doucment.body.scrollTop<br>  和document.documentElement.scrollLeft/document.documentElement.scrollTop</strong></p><p>这里要说明的是，<font color="red">这两种方法要一起使用</font>，因为浏览器的兼容性问题，有的浏览器是document.body有值，有的是document.documentElement有值，<font color="red">但是所有的浏览器都只有一个有值，不会两个都有或者一个都没有</font>，而且这里的没有值不代表是null，而是0，因此我们使用的时候一般都是两个一起使用。</p><p>针对兼容性的问题，我们现在就可以封装一个函数，求滚动条滚动距离的方法。</p><pre><code>function getScrollOffset(){    if(window.pageXOffset){        return {            x : window.pageXOffset,            y : window.pageYOffset        }    }else{        return {            x : document.body.scrollLeft + document.documentElement.scrollLeft,            y : document.body.scrollTop + document.documentElement.scrollTop        }    }}</code></pre><h4 id="查看视口的尺寸"><a href="#查看视口的尺寸" class="headerlink" title="查看视口的尺寸"></a><font color="red">查看视口的尺寸</font></h4><p><strong>window.innerWidth/window.innerHeight</strong><br>但IE8及IE8以下不兼容   </p><p><strong>标准模式下(有 &lt;!DOCTYPE html&gt; 声明)</strong><br><strong>document.documentElement.clientWidth/clientHeight</strong><br><strong>怪异模式下(无 &lt;!DOCTYPE html&gt; 声明)</strong><br><strong>document.body.clientWidth/clientHeight</strong></p><p>• 什么是怪异模式和标准模式呢？</p><p>浏览器的渲染模式有两种：<font color="red">标准模式和怪异模式</font>。我们常用的是标准模式，怪异模式是防止浏览器升级版本过高对后面版本你的代码不兼容，让浏览器可以向后兼容其他低版本的代码的法规则，比如IE6的怪异模式下可以兼容IE5个IE4的语法。</p><p>•  我们如何变成怪异模式呢？</p><p>其实很简单，只需要把我们html代码的第一行的<font color="red">&lt;!DOCTYPE HTML&gt;</font>去掉就可以变成怪异模式了，而加上这一行代码就可以变成标准模式。</p><p>• 如何判断怪异模式还是标准模式？</p><p>document上中有一个方法叫做<font color="red">compatMode</font>，当浏览器处于怪异模式的时候会返回字符串”<font color="red">BackCompat</font>“，在标准模式下可以返回”<font color="red">CSS1Compat</font>“，通过这个方法我们就可以判断了。</p><p>封装兼容性方法,返回浏览器视口尺寸</p><pre><code>function getViewportOffset(){    if(window.innerWidth){        return {            x : window.innerWidth,            y : window.innerHeight        }    }else{        if(document.compatMode === &quot;BackCompat&quot;){            return {                w : document.body.clientWidth,                h : document.body.clientHeight            }        }else{            return {                w : document.documentElement.clientWidth,                h : document.documentElement.clientHeight            }        }    }}</code></pre><h4 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸"></a><font color="red">查看元素的几何尺寸</font></h4><p><strong><font color="red">domEle.getBoundingClientRect()</font></strong></p><p>在获取的dom元素上，有一个getBoundingClientRect方法，这个方法可以获取到元素的宽高和左上点的位置以及有下点的位置（width、height、top、left、right、bottom）</p><p>但是<font color="red">老版本的IE浏览器没有实现width和height</font>，那么我们在老版本的IE计算宽高的时候就需要用<font color="red">bottom-top</font>和<font color="red">right-left</font>来计算宽高值了。</p><p>还有一点需要注意的是，这里的宽高也不是实时更新的，数据只是一个副本。<br>我们依然可以封装一个函数，可以返回元素的宽高。</p><pre><code>Element.getElementOffset() {      var objData = this.getBoundingClientRect();      if(objData.width) {            return {                  w: objData.width,                  h: objData.height            }      }else {            return {                  w: objData.right - objData.left,                  h: objData.bottom - objData.top            }      }}</code></pre><p><strong><font color="red">查看元素的尺寸</font></strong></p><p><strong>dom.offsetWidth<br>dom.offsetHeight</strong></p><p><strong><font color="red">查看元素的位置</font></strong></p><p><strong>dom.offsetLeft<br>dom.offsetTop</strong><br>对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。</p><p><strong>dom.offsetParent</strong><br>返回最近的有定位的父级，如无，返回body, body.offsetParent 返回null</p><p><strong><font color="red">滚动条滚动</font></strong></p><p>window上有三个方法<br><strong>scroll()、scrollTo()、scrollBy();</strong><br>三个方法功能类似，用法都是将x,y坐标传入。即实现让滚动轮滚动到当前位置。<br>区别：scrollBy()会在之前的数据基础之上做累加。</p><p>利用scrollBy() 快速阅读的功能</p><pre><code>function scrollBy(){    var start = document.getElementsByTagName(&apos;div&apos;)[0];    var stop = document.getElementsByTagName(&apos;div&apos;)[1];    var timer = 0;    var key = true;    start.onclick = function(){        if(key){            timer = setInterval(function(){                window.scrollBy(0, 10);            }, 100);            key = false;        }    }    stop.onclick = function(){        clearInterval(timer);        key = true;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;查看滚动条的滚动距离&quot;&gt;&lt;a href=&quot;#查看滚动条的滚动距离&quot; class=&quot;headerlink&quot; title=&quot;查看滚动条的滚动距离&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;查看滚动条的滚动距离&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;js中有两套方法可以查看当
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Date对象与定时器</title>
    <link href="http://yoursite.com/2018/11/30/Date%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2018/11/30/Date对象与定时器/</id>
    <published>2018-11-30T09:16:33.000Z</published>
    <updated>2018-12-19T06:34:02.393Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color="red">日期对象</font></strong></p><p>日期对象的方法在w3c上其实有介绍<br><a href="http://www.w3school.com.cn/jsref/jsref_obj_date.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/jsref/jsref_obj_date.asp</a></p><pre><code>var date = new Date();date.getFullyear();</code></pre><p><strong><font color="red">时间戳</font></strong></p><pre><code>var firstTime = new Date().getTime();for(var i = 0;i &lt; 1000000000;i++){}var lastTime = new Date().getTime();console.log(lastTime-firstTime);</code></pre><p><strong><font color="red">定时器</font></strong></p><p><strong>setInterval()</strong><br>setInterval()里面的第二个参数是<font color="red">不能修改</font>就算你修改变量定时器内的time依然是1000,如下</p><pre><code>var time = 1000;setInterval(function(){    consloe.log(&quot;a&quot;);}, time);time = 2000;</code></pre><p><strong>clearInterval();清除定时器</strong><br>1代表就是这个定时器,依次类推后面的定时器就是2…</p><pre><code>var i = 0;setInterval(function(){    console.log(i++);    if(i &gt; 10){        clearInterval(1);    }}, 100);</code></pre><p><strong>setTimeout()和clearTimeout() 仅执行一次</strong></p><pre><code>var timer = setTimeout(function(){   console.log(&quot;a&quot;);}, 1000);clearTimeout(timer);</code></pre><p>setInterval() setTimeout() clearInterval() clearTimeout() 都是全局对象window上的方法<br>内部函数this指向window</p><p>例</p><pre><code>minutes: &lt;input type=&quot;text&quot; value=&quot;0&quot;&gt;seconds: &lt;input type=&quot;text&quot; value=&quot;0&quot;&gt;&lt;script&gt;    var minutesNode = document.getElementsByTagName(&apos;input&apos;)[0];    var secondsNode = document.getElementsByTagName(&apos;input&apos;)[1];    var minutes = 0,        seconds = 0;    var timer = setInterval(function(){        seconds ++;        if(seconds == 60){            seconds = 0;            minutes ++;        }        secondsNode.value = seconds;        minutesNode.value = minutes;        if(minutes == 3){            clearInterval(timer);        }    }, 100);&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;日期对象&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日期对象的方法在w3c上其实有介绍&lt;br&gt;&lt;a href=&quot;http://www.w3school.com.cn/jsref/jsref_obj_date.asp&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOM基础练习</title>
    <link href="http://yoursite.com/2018/11/29/DOM%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/11/29/DOM基础练习/</id>
    <published>2018-11-29T09:16:33.000Z</published>
    <updated>2018-12-19T08:33:55.882Z</updated>
    
    <content type="html"><![CDATA[<p><strong>遍历元素节点树</strong></p><pre><code>function retChild(node) {     var child = node.childNodes,           len = child.length;     for(var i = 0; i &lt; len; i++){           if(child[i].nodeType === 1) {                console.log(child[i]);               child[i].hasChildNodes() &amp;&amp; retChild(child[i]);           }      } }   </code></pre><p><strong>返回元素elem的第n层父元素的节点</strong></p><pre><code>function retParent(elem, n){    //与elem 解决兼容性容错  比如n足够大会报错而此时会返回null    while(elem &amp;&amp; n){               elem = elem.parentElement;        n --;    }    return elem;}var i = document.getElementsByTagName(&apos;i&apos;)[0];</code></pre><p><strong>封装myChildren功能,解决以前部分浏览器的兼容性问题</strong></p><pre><code>Element.prototype.myChildren = function(){    var child = this.childNodes;    var len = child.length;    var arr = [];    for(var i = 0;i &lt; len;i++){        if(child[i].nodeType == 1){            arr.push(child[i]);        }    }    return arr;}var div = document.getElementsByTagName(&apos;div&apos;)[0];</code></pre><p><strong>封装函数,返回元素e的第n个兄弟元素节点n为正,返回后面的兄弟节点,n为负,返回前面的,n为0,返回自己</strong></p><pre><code>function retSibling(e, n){    while( e &amp;&amp; n){//n = 0 循环退出     e &amp;&amp;: 解决兼容性容错        if( n &gt; 0){            if(0 &amp;&amp; e.nextElementSibling){                e = e.nextElementSibling;            }else{                // 将e的下一个兄弟节点赋值给e 然后看e节点类型是否是元素节点 不是就一直重复                // e &amp;&amp; :e如果为null会报错 e得有意义                for(e = e.nextSibling; e &amp;&amp; e.nodeType != 1;e = e.nextSibling);            }            n --;        }else{            if(e.previousElementSibling){                e = e.previousElementSibling;            }else{                for(e = e.previousElementSibling; e &amp;&amp; e.nodeType !=1;                e = e.previousElementSibling);            }            n ++;        }    }    return e;}</code></pre><p><strong>封装是否有元素子节点的方法</strong></p><pre><code>Element.prototype.hasChildren = function () {      var child = this.childNodes,            len = child.length;      for( var i = 0; i &lt; len; i++){            if(child[i].nodeType == 1) {                  return true;            }      }      return false;}   </code></pre><p><strong>封装insertAfter方法,与insertBefore方法类似</strong></p><pre><code>Element.prototype.insertAfter = function(targetNode, afterNode){    var beforeNode = afterNode.nextElementSibling;    if(beforeNode == null){//如果afterNode的下一个兄弟元素不存在        this.appendChild(targetNode);//直接添加在最后面    }else{        this.insertBefore(targetNode, beforeNode);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;遍历元素节点树&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function retChild(node) {
     var child = node.childNodes,
           len = child.length;
     f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOM基本操作</title>
    <link href="http://yoursite.com/2018/11/29/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/11/29/DOM基本操作/</id>
    <published>2018-11-29T09:16:33.000Z</published>
    <updated>2018-12-25T02:33:15.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a><font color="red">什么是DOM</font></h2><p>• DOM的全称是<font color="red">Document Object Model 文档对象模型</font>，DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。</p><p>• DOM对象即为宿主对象，由浏览器厂商定义，用来操作html的css功能的一类对象和集合。不过浏览器厂商之间大部分都遵循w3c标准</p><p>• 简单来说，<font color="red">DOM就是用来操作html和css的，它是一系列对象的集合</font>。</p><h2 id="DOM如何操作HTML"><a href="#DOM如何操作HTML" class="headerlink" title="DOM如何操作HTML"></a><font color="red">DOM如何操作HTML</font></h2><p>document代表整个文档，它也是一个dom元素，我们dom对html的操作，即使对html的增删改查。下面我就介绍一下dom都是如何增删改查html的。</p><p>那么我们如何查看元素节点？</p><p>•  <font color="red"><strong>document.getElementById();</strong></font>   元素id 在Ie8以下的浏览器,不区分id大小写,而且也返回匹配name属性的元素<br>•  <font color="red"><strong>getElementsByTagName();</strong></font>    标签名<br>•  <font color="red"><strong>getElementByName();</strong></font>       需注意,只有部分标签name可生效(表单,表单元素,img,iframe)<br>•  <font color="red"><strong>getElementsByClassName();</strong></font>  类名 ie8和ie8以下的ie版本中没有,可以多个class一起</p><pre><code>var div = document.getElementsByClassName(&apos;demo demo1&apos;)[0];</code></pre><p>注意: 以上都是’实时’的</p><p>•  <font color="red"><strong>querySelector();</strong></font><br>•  <font color="red"><strong>querySelectorAll();</strong></font></p><p>我们知道选择元素最强的是css，而这两个里面写的参数就是我们css选择器的写法。<br>不过querySelector永远选择一组里面的第一个，所以返回的不是一个类数组而是一个具体的元素。<br>而我们如果要返回一个类数组的集合的话，那么就用第二个querySelectorAll()方法。</p><pre><code>document.querySelector(&apos;div p #demo .demo&apos;);</code></pre><p>不过这两个方法的问题在于，他们返回的不像前面四个是一个实时改变的元素，而是一个副本。当我们用这两个方法选择出来元素之后，我们把本身那个元素修改一下，会发现我们选择出来的那个元素没有变化。<br>注意: css选择器 在ie7和ie7以下的版本中没有</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a><font color="red">节点</font></h2><p>•  节点类型 ———— nodeType<br>•  元素节点 ———— 1<br>•  属性节点 ———— 2<br>•  文本节点 ———— 3<br>•  注释节点 ———— 8<br>•  document ———— 9<br>•  DocumentFragment ———— 11</p><p><strong><font color="red">节点的四个属性</font></strong></p><ol><li>nodeName     元素的标签名,以大写形式表示 只读</li><li>nodeValue    Text节点或Comment节点的文本内容 可读写</li><li>nodeType     该节点的类型 只读</li><li>attributes   Element 节点的属性集合</li></ol><p><strong><font color="red">节点的一个方法</font></strong><br>  Node.hasChildNodes();  判断是否有子节点</p><p><strong><font color="red">遍历节点树</font></strong></p><p>•  parentNode      ——&gt; 父节点<br>•  childNodes      ——&gt; 子节点<br>•  firstChild      ——&gt; 第一个子节点<br>•  lastChild       ——&gt; 最后一个子节点<br>•  nextSibling     ——&gt; 下一个兄弟节点<br>•  previousSibling ——&gt; 前一个兄弟节点</p><p><strong><font color="red">元素节点树的遍历</font></strong></p><p>•  parentElement          ——&gt; 返回当前元素的父元素节点 (IE不兼容)<br>•  children               ——&gt; 只返回当前元素的元素子节点<br>•  node.childElementCount === node.children.length当前元素节点的子元素节点个数(IE不兼容)<br>•  firstElementChild      ——&gt; 返回的是第一个元素节点(IE不兼容)<br>•  lastElementChild       ——&gt; 返回的是最后一个元素节点(IE不兼容)<br>•  nextElementSibling     ——&gt; 返回后一个元素节点（IE不兼容)<br>•  previousElementSibling ——&gt; 前一个兄弟元素节点（IE不兼容)</p><p>例</p><pre><code>&lt;div&gt;    &lt;!-- This is comment --&gt;    &lt;strong&gt;&lt;/strong&gt;    &lt;span&gt;&lt;/span&gt;&lt;/div&gt;该div里面有多少个节点?var div = document.getElementsByTagName(&apos;div&apos;);div.childNodes;// 7个节点</code></pre><h2 id="DOM树结构"><a href="#DOM树结构" class="headerlink" title="DOM树结构"></a><font color="red">DOM树结构</font></h2><p><img src="https://i.imgur.com/gLybWJ7.png" alt=""></p><p>1.<strong>getElementById</strong>         方法定义在Document.prototype上，即Element节点上不能使用。<br>2.<strong>getElementsByName</strong>       方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用(xml document,Element)<br>3.<strong>getElementsByTagName</strong>    方法定义在Document.prototype 和 Element.prototype上<br>4.<strong>HTMLDocument.prototype</strong>  定义了一些常用的属性，body,head,分别指代HTML文档中的<body><head><meta name="generator" content="Hexo 3.8.0">标签。<br>5.<strong>Document.prototype</strong>      上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代<html>元素<br>6.<strong>getElementsByClassName、querySelectorAll、querySelector</strong> 在Document,Element类中均有定义</html></head></body></p><h2 id="DOM的增删改查"><a href="#DOM的增删改查" class="headerlink" title="DOM的增删改查"></a><font color="red">DOM的增删改查</font></h2><p><strong><font color="red">增加操作</font></strong></p><p>1.<font color="red"><strong>创建元素节点 createElement</strong></font></p><pre><code>var div = document.createElement(&apos;div&apos;);</code></pre><p>2.<font color="red"><strong>创建文本节点 document.createTextNode</strong></font></p><pre><code>var text = document.createTextNode(&apos;hello&apos;);   </code></pre><p>3.<font color="red"><strong>创建注释节点 document.createComment</strong></font></p><pre><code>var comment = document.createComment(&apos;comment&apos;);   </code></pre><p>4.<font color="red"><strong>创建文档碎片 document.createDocumentFragment</strong></font><br>这个方法可以创建一个文档碎片，我们在后面讲的有关提高性能的部分会用到这个方法。</p><p><strong><font color="red">插入操作</font></strong></p><p>1.<font color="red"><strong>appendChild(child);</strong></font></p><p>这个是父级调用的方法，它会将child元素插入到父级里面，而且是放到逻辑后面的位置上。</p><pre><code>div.appendChild(text);div.appendChild(comment);</code></pre><p>2.<font color="red"><strong>insertBefore(a, b);</strong></font></p><p>这个依然是父节点调用的方法，它的意思是将a插入到b前面的位置上，其中b要求是这个父级的子节点。这个方法可以记作为 insert a before b;</p><pre><code>var span = document.createElement(&apos;span&apos;);div.insertBefore(span, comment);// 把一个span元素插入到了刚才的注释文本前面</code></pre><p><strong><font color="red">删除操作</font></strong></p><font color="red"><strong>removeChild</strong></font><p>这个方法依然是父级调用的，参数就是要删除的子节点，其实实际上是剪切，这个方法会把我们删除掉的元素给返回，我们可以用一个变量去保存这个被删除的元素。</p><pre><code>var div = document.body.remove(div);</code></pre><p><strong><font color="red">替换操作</font></strong></p><font color="red"><strong>replaceChild(new, origin)</strong></font><p>这个方法同样是父级调用，用新的元素new来替换原来的origin元素，原来的被替换掉的元素可以被返回，我们可以像删除操作那样用一个变量来保存。</p><h2 id="Element节点的属性和方法"><a href="#Element节点的属性和方法" class="headerlink" title="Element节点的属性和方法"></a><font color="red">Element节点的属性和方法</font></h2><p><strong>属性:</strong></p><p>1.<strong><font color="red">innerHTML</font></strong></p><pre><code>div.innerHML = &apos;&lt;div&gt;123&lt;/div&gt;&apos;;</code></pre><p>我们可以直接通过这个属性来改变元素内部的结构和内容，不过注意它会直接删除掉以前的所有结构</p><p>2.<strong><font color="red">innerText/textContent</font></strong></p><p>innerText(火狐不兼容) / textContent(老版本IE不兼容)<br>这个属性可以直接调出来元素内部的文本信息，若果这个元素还有很多的子元素的话，那么会把子元素里面的文本信息一起返回。<br>不过需要注意的是，如果我们要改写innerText或者textContent的话，它会像innerHTML一样，<strong>先把内部的所有html结构先删除掉</strong>，然后再写入text文本</p><p>• 这里提一下，如果我们有很多字符串要添加到一个元素的内部的话，虽然用innerHTML或者innerText方法，但是却不是用innerHML += str的方法，因为+=操作符的效率极低，当字符串很多的时候会非常非常消耗性能。</p><p>遇到这种情况我们一般是用数组的join方法将字符串全部连接成一个字符串，然后一次性写入innerHTML。</p><p><strong>方法:</strong></p><p>1.<strong><font color="red">ele.setAttribute();</font></strong><br>这个方法可以设置元素的属性（特性），比如class、id等一些行间属性。</p><pre><code>div.setAttribute(&apos;id&apos;, &apos;demo&apos;);   </code></pre><p>2.<strong><font color="red">ele.getAttribute();</font></strong><br>这个方法是获取元素的行间属性。</p><pre><code>&lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;&lt;strong&gt;&lt;/strong&gt;var all = document.getElementsByTagName(&apos;*&apos;);//选中所有标签for(var i = 0;i &lt; all.length;i++){    all[i].setAttribute(&apos;this-name&apos;, all[i].nodeName);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是DOM&quot;&gt;&lt;a href=&quot;#什么是DOM&quot; class=&quot;headerlink&quot; title=&quot;什么是DOM&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;什么是DOM&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;• DOM的全称是&lt;font color=&quot;red&quot;&gt;Do
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2018/11/28/%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/11/28/数组/</id>
    <published>2018-11-28T09:16:33.000Z</published>
    <updated>2018-12-19T03:16:53.439Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><font color="red">数组</font></h4><p><strong><font color="red">两种构造方法:</font></strong></p><p>1.字面量</p><pre><code>var arr = [1,2,,,,3,4];</code></pre><p> 上面这种数组属于<font color="red">稀松数组</font></p><p>2.构造函数</p><pre><code>var arr = new Array(1,2,3,4);</code></pre><p> JavaScript里的数组是基于对象的  即数组是一种特殊的对象</p><pre><code>var arr = new Array(10);var arr1 = [10];</code></pre><p> 这里arr创建了10个空数组，而arr1创建了1个参数为10的数组</p><h4 id="判断数组类型"><a href="#判断数组类型" class="headerlink" title="判断数组类型"></a><font color="red">判断数组类型</font></h4><p> 给定一个未知对象,判定他是否为数组 在es5中可以使用Array.isArray()函数来判断</p><pre><code>Array.isArray([]);// trueArray.isArray({});// falseArray.isArray(1);// false</code></pre><p>在es5之前,大家可能想到利用typeof操作符来判断,但是无论是数组还是对象,均返回对象</p><pre><code>typeof [];// objecttypeof {};// object</code></pre><p>在es3中isArray()可以使用Object.prototype.toString.call(arr) === ‘[object Array]’代替</p><pre><code>Object.prototype.toString.call([]);// &apos;[object Array]&apos;Object.prototype.toString.call({});// &apos;[object Object]&apos;</code></pre><p><strong><font color="red">数组的添加和删除</font></strong></p><p>• <strong>添加</strong><br>    1.最简单的方法：为新索引赋值<br>    2.使用push()和unshift()方法</p><p>• <strong>删除</strong><br>    1.delete运算符删除数组元素(不会修改数组的length属性)<br>    2.使用pop()和shuift()方法</p><h4 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a><font color="red">数组的常用方法</font></h4><p> • <strong><font color="red">改变原数组: push, pop, shift, unshift, sort, reverse, splice</font></strong></p><p> • <strong><font color="red">不改变原数组: concat, join , split, toString, slice</font></strong></p><h4 id="push-在最后一位添加"><a href="#push-在最后一位添加" class="headerlink" title="push (在最后一位添加)"></a><font color="red">push (在最后一位添加)</font></h4><pre><code>var arr = [1,2];Array.prototype.push = function (){for(var i=0;i&lt;arguments.length;i++){    this[this.length] = arguments[i];}    return this.length;}</code></pre><h4 id="pop-在最后一位剪切"><a href="#pop-在最后一位剪切" class="headerlink" title="pop (在最后一位剪切)"></a><font color="red">pop (在最后一位剪切)</font></h4><h4 id="shift-在最前面剪切"><a href="#shift-在最前面剪切" class="headerlink" title="shift (在最前面剪切)"></a><font color="red">shift (在最前面剪切)</font></h4><h4 id="unshift-在最前面添加"><a href="#unshift-在最前面添加" class="headerlink" title="unshift (在最前面添加)"></a><font color="red">unshift (在最前面添加)</font></h4><h4 id="reverse-反转"><a href="#reverse-反转" class="headerlink" title="reverse (反转)"></a><font color="red">reverse (反转)</font></h4><pre><code>var arr = [1, 2, 3, 4, 5];arr.reverse();// [5, 4, 3, 2, 1]</code></pre><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a><font color="red">splice</font></h4><p><strong>arr.splice(从第几位开始, 截取多少的长度, 在切口处添加新的数据);</strong></p><pre><code>var arr = [1, 1, 2, 2, 3, 3];arr.splice(1, 2);// 删除 arr = [1,2,3,3]  arr.splice(1, 1, 0,0,0);// 替换 arr = [1, 0, 0, 0, 2, 2, 3, 3]arr.splice(3, 0, 4);// 等同于在第三位添加4var arr = [1,2,3,4]arr.splice(-1, 1);//arr = [1,2,3]   -1+lengtharr.splice(-1, 2);//arr = [1,2] </code></pre><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort (排序)"></a><font color="red">sort (排序)</font></h4><pre><code>var arr = [1,3,5,4,10];arr.sort();//按照ascll码排序</code></pre><p><strong>自定义排序:<br>            1.必须写两形参<br>            2.看返回值:<br>                       1)当返回值为负数时,那么前面的数放在前面<br>                       2) 为正数,那么后面的数在前<br>                       3) 为0,不动</strong></p><pre><code>var arr = [3,1,5,10,4];arr.sort(function(a, b){    if(a &gt; b){          return 1;    }else{        return -1;    }});//升序 a &gt; b ; 降序a &lt; bvar arr = [3,1,5,10,4];arr.sort(function(a, b){    return a - b;});// return a - b;升序    // return b - a;降序  </code></pre><p>给一个有序的数组,乱序:</p><pre><code>var arr = [1,2,3,4,5,6,7,8];arr.sort(function(a, b){    return Math.random()-0.5;});</code></pre><p>按照对象年龄大小排序:</p><pre><code>var cheng = {    name : &quot;cheng&quot;,    age : 30,    sex : &quot;male&quot;}var deng = {    name : &quot;deng&quot;,    age : 50,    sex : &quot;male&quot;}var zhang = {    name : &quot;zhang&quot;,    age : 40,    sex : &quot;female&quot;}var arr = [cheng, deng, zhang];arr.sort(function(a, b){    return a.age - b.age;});</code></pre><p>按照字符串长度排序:</p><pre><code>function retBytes(str){    var num = str.length;    for(var i=0;i&lt;str.length;i++){        if(str.charCodeAt(i)&gt;255){            num ++;        }    }    return num;}var  arr = [&apos;a邓&apos;, &apos;bd邓&apos;, &apos;cc老邓&apos;, &apos;ddddd&apos;, &apos;slkhadkhja&apos;];arr.sort(function(a, b){    return retBytes(a) - retBytes(b);});</code></pre><h4 id="concat-拼接-连接"><a href="#concat-拼接-连接" class="headerlink" title="concat (拼接/连接)"></a><font color="red">concat (拼接/连接)</font></h4><pre><code>var arr = [1,2,3];var arr1 = [3,2,1];var arr2 = arr.concat(arr1);// [1,2,3,3,2,1]</code></pre><h4 id="slice"><a href="#slice" class="headerlink" title="slice "></a><font color="red">slice </font></h4><p>从该位开始截取, 截取到该位(不包括)</p><pre><code>var arr = [5,4,3,2,1,6];var newArr = arr.slice(1, 4);// [4, 3, 2]var newArr1 = arr.slice(1);// [4, 3, 2, 1, 6]</code></pre><h4 id="join"><a href="#join" class="headerlink" title="join"></a><font color="red">join</font></h4><p>将数组中所有元素都转化成字符串并连接在一起，返回最后生成的字符串<br>可以选择一个可选的字符串在生成的字符串中来分隔数组的各个元素。<br>如果不指定使用分隔符，默认使用逗号。不修改原数组。</p><pre><code>var arr = [1,2,3];var newArr = arr.join(&quot;-&quot;);//&quot;1-2-3&quot;</code></pre><p>利用join(“”)可以实现大量字符串拼接</p><pre><code>var str = &quot;das&quot;;var str1 = &quot;dqqd&quot;;var str2 = &quot;fvmixk&quot;;var str3 = &quot;qqqmlx&quot;;var str4 = &quot;zmcxol&quot;;var str5 = &quot;qpuh&quot;;var str6 = &quot;lough&quot;;var f = &quot;&quot;;var arr = [str,str1,str2,str3,str4,str5,str6,f];var newArr = arr.join(&quot;&quot;);</code></pre><h4 id="split"><a href="#split" class="headerlink" title="split"></a><font color="red">split</font></h4><p>split()方法是按照给定的字符串将字符串分割成若干块来创建一个数组。</p><pre><code>var arr1 = newArr.split(&quot;-&quot;);//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</code></pre><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a><font color="red">indexOf</font></h4><p>返回某个指定的字符串值在数组中首次出现的位置，从头至尾搜索，没有则返回-1</p><pre><code>var arr = [1, 1, 2, 3, 5, 5];arr.indexOf(1);// 0</code></pre><h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a><font color="red">lastIndexOf</font></h4><p>返回某个指定的字符串值在数组中最后一次出现的位置，从尾至头搜索，没有则返回-1</p><pre><code>arr.lastIndexOf(5);// 5</code></pre><p>同时我们可以在方法中传入两个参数，第一个参数代表需要搜索的值，第二个参数代表从哪一位开始搜索</p><pre><code>arr.indexOf(1,1);// 1</code></pre><p>重写myIndexOf函数</p><pre><code>Array.prototype.myIndexOf = function(){    var startIndex = 0;    var args = arguments;    var len = this.length;    if(args[1]){// 如果有第二个参数         startIndex = args[1];    }    for(var i = startIndex;i &lt; len;i++){        if(this[i] == args[0]){// 参数一            return i;// 返回参数一的索引值        }    }    return -1;}</code></pre><h4 id="reduce-和reduceRight"><a href="#reduce-和reduceRight" class="headerlink" title="reduce()和reduceRight()"></a><font color="red">reduce()和reduceRight()</font></h4><p>1.reduce()和reduceRight()方法使用指定的函数将数组元素进行组合,生成单个值。</p><p>reduce()可以传入两个参数,第一个是执行化简操作的函数.同样这个函数可以有参数,<br> • 第一个参数代表之前所有元素的累积结果<br> • 第二个参数代表当前进行运算的元素<br> • 第三个参数代表当前运算参数的索引值<br> • 第四个参数代表调用方法的原数组<br>第二个参数是可选的,是一个传递给函数的初始值.如果第二个参数有值,那么作为运算的初始值参与函数运算,如果第二个参数没有值,那么数组中的首位将作为函数运算的初始值,参与函数运算的数组其他位向后平移一位</p><p>reduceRight()和reduce()使用方法一致,但是reduceRight()进行函数运算从右到左.传参形式均一致.</p><pre><code>var arr = [1, 2, 3, 4, 5];var b = arr.reduce(function(last, now, index, arr){    console.log(last, now, index, arr);    return last + now;}, 10);</code></pre><p>重写myReduce函数</p><pre><code>Array.prototype.myReduce = function(func, init){    var len = this.length;    var prev = init;    var i = 0;    if(init == undefined){// 不传第二个参数        prev = this[0];        i = 1;    }    for(i;i &lt; len;i++){        prev = func(prev, this[i], i,this);    }    return prev;};</code></pre><p>例: 获得当前时间并将其转换成字符串形式,个位数用零补齐.例如8点45分零五秒转化成084505.</p><pre><code>var date = new Date();var arr = [date.getHours(), date.getMinutes(), date.getSeconds()];var str = arr.reduce(function(last, now){    return last + (&apos;0&apos; + now).slice(-2);}, &apos;&apos;);</code></pre><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><font color="red">filter</font></h4><p><strong>数组的过滤</strong></p><p>filter()方法返回的数组元素是调用的数组的一个子集。<br>传递函数是用来逻辑判断的,该函数返回true或false.如果返回值为true或能转化成true的值,那么传递给判定函数的元素就是这个子集的成员,将被添加到一个作为返回值的数组中。<br>filter()方法的结果返回一个满足条件的数组，不修改原数组。<br>注意：filter()方法会跳过稀疏数组中缺少的元素，他的返回值总是非稀疏的。</p><pre><code>var arr = [0, 1, 2, 3, 45, 5];var a = arr.filter(function(ele){    return ele &gt; 3;});</code></pre><p>重写myFilter函数</p><pre><code>Array.prototype.myFilter = function(func){    var newArr = [];    for(var i = 0;i &lt; this.length;i++){// 遍历原数组        if(func(this[i], i)){              newArr.push(this[i]);        }    }    return newArr;}</code></pre><h4 id="every"><a href="#every" class="headerlink" title="every"></a><font color="red">every</font></h4><p><strong>数组的逻辑判定</strong></p><p>返回true或false,every()相当于与,当且仅当数组中的所有元素都满足调用函数的条件,返回true</p><pre><code>var arr = [1, 1, 2, 3, 45, 5, 5, 5];arr.every(function(ele){    return ele &lt; 10;});// falsearr.every(function(ele){    return ele &lt; 100;});// true</code></pre><h4 id="some"><a href="#some" class="headerlink" title="some"></a><font color="red">some</font></h4><p>返回true或false,some()相当于或,当数组中至少有一个元素调用判定函数返回true,它的返回值就是true,所有元素均不满足函数条件，则返回false</p><pre><code>var arr = [1, 1, 2, 3, 45, 5, 5, 5];arr.some(function(ele){    return ele &lt; 10;});// truearr.some(function(ele){    return ele &lt; 0;});// false</code></pre><p>注意：一旦every()和some()确认返回值的时候就会停止遍历数组</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><font color="red">forEach</font></h4><p>数组遍历 forEach()方法</p><p>forEach()的使用方法：forEach方法从头至尾遍历数组，对每个元素调用指定的函数。<br>forEach方法传入参数为一个函数，函数 可以传入三个参数，按照顺序分别为,数组元素、元素索引和数组本身。不强制同时传入三个参数，可以按照需求传入参数个数。</p><p>重写myForEach函数</p><pre><code>Array.prototype.myForEach = function(fn){    for(var i = 0;i &lt; this.length;i++){// this代表调用myForEach方法的数组        fn(this[i], i);// 将数组的每一位this[i]及代表数组索引 i 作为函数参数    }// 同时在for循环中执行参数fn函数}</code></pre><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a><font color="red">类数组</font></h4><p>我们知道有两种数据叫做数组和对象，但是我们其实可以用对象来模拟出数组的效果，我们把这种对象叫做类数组。我们前面提到的<font color="red">arguments实参列表就是一个类数组</font>。</p><p>类数组<font color="red">并不是一个数组</font>，但是它可以表现出数组的特性。</p><p><font color="red">属性要为索引(数字)属性</font>,<font color="red">必须有length属性</font>,最好加上push<br>好处:将数组和对象的方法都拼到一起,但不是所有方法都可以用</p><pre><code>var obj = {    &quot;0&quot; : &apos;a&apos;,    &quot;1&quot; : &apos;b&apos;,    &quot;2&quot; : &apos;c&apos;,    &quot;length&quot; : 3,    &quot;push&quot; : Array.prototype.push,    &quot;splice&quot; : Array.prototype.splice}Array.prototype.push = function (target){    this[this.length] = target;    this.length ++;}</code></pre><p>这样我们就创造了一个类数组，现在它就可以表现出数组的特性了。</p><pre><code>obj.push(d);console.log(obj);var obj = {    &quot;0&quot; : &apos;a&apos;,    &quot;1&quot; : &apos;b&apos;,    &quot;2&quot; : &apos;c&apos;,    &quot;3&quot; : &apos;d&apos;,    &quot;length&quot; : 4,    &quot;push&quot; : Array.prototype.push,    &quot;splice&quot; : Array.prototype.splice}</code></pre><p>其实类数组的<font color="red">关键就在这个length属性</font>上，如果没有length属性，那么就是一个普通的对象，即使有push方法也不能使用。</p><p>现在我们有一个这样的题：</p><pre><code>var arrobj = {    &quot;3&quot; : 1,    &quot;4&quot; : 2,    &quot;a&quot; : 3,    &quot;b&quot; : 4,    &quot;length&quot; : 2,    &quot;push&quot; : Array.prototype.push,}arrobj.push(3);arrobj.push(6);</code></pre><p>仔细看一下push的方法之后，我们就知道了，最后的arrObj应该是这个样子的：</p><pre><code>var arrobj = {    &quot;2&quot; : 3,    &quot;3&quot; : 6,    &quot;4&quot; : 2,    &quot;a&quot; : 3,    &quot;b&quot; : 4,    &quot;length&quot; : 4,    &quot;push&quot; : Array.prototype.push,}</code></pre><p>这里的length是2，所以一开始push(3)的时候把arrObj[2]改成了3，因为本身没有2这个下标，所以添加一条属性2:3，然后length变成了3，push(6)之后，arrObj[3]变成了6，本身有3这一条属性所以覆盖，然后把length变成4。</p><p>再来看一题：</p><pre><code>var obj = {    &quot;2&quot; : &quot;a&quot;,    &quot;3&quot; : &quot;b&quot;,    &quot;length&quot; : 2,    &quot;push&quot; : Array.prototype.push}obj.push(&apos;c&apos;);obj.push(&apos;d&apos;);</code></pre><p>执行obj.push(‘c’)之后 obj变成</p><pre><code>var obj = {    &quot;2&quot; : &quot;c&quot;,    &quot;3&quot; : &quot;b&quot;,    &quot;length&quot; : 3,    &quot;push&quot; : Array.prototype.push}</code></pre><p>接着执行obj.push(‘c’)之后 obj变成</p><pre><code>var obj = {    &quot;2&quot; : &quot;c&quot;,    &quot;3&quot; : &quot;d&quot;,    &quot;length&quot; : 4,    &quot;push&quot; : Array.prototype.push}</code></pre><h4 id="封装一个type工具方法"><a href="#封装一个type工具方法" class="headerlink" title="封装一个type工具方法"></a><font color="red">封装一个type工具方法</font></h4><p> 1.分两类  原始值 引用值<br> 2.区分引用值<br> 1)数组 2)对象 3)包装类</p><pre><code>function type(target){    var template = {        &quot;[object Array]&quot; : &quot;array&quot;,        &quot;[object Object]&quot; : &quot;object&quot;,        &quot;[object Number]&quot; : &quot;number - object&quot;,        &quot;[object Boolean]&quot; : &quot;boolean - object&quot;,        &quot;[object String]&quot; : &quot;string - object&quot;    }    if(target === null){        return null;    }else if(typeof(target) == &apos;object&apos;){        var str = Object.prototype.toString.call(target);        return template[str];    }else{        return typeof(target);    }}</code></pre><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a><font color="red">数组去重</font></h4><pre><code>var arr = [1,1,1,1,1,2,2,2,2,1];Array.prototype.unique = function(){    var temp = {};    var arr = [];    var len = this.length;    for(var i=0;i&lt;len;i++){        if(!temp[this[i]]){            temp[this[i]] = &quot;abc&quot;;            arr.push(this[i]);        }    }    return arr;}var newArr = arr.unique();</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;数组&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;两种构造方法:&lt;/font&gt;&lt;/str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>克隆算法</title>
    <link href="http://yoursite.com/2018/11/27/%E5%85%8B%E9%9A%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/27/克隆算法/</id>
    <published>2018-11-27T09:16:33.000Z</published>
    <updated>2018-12-25T02:29:19.161Z</updated>
    
    <content type="html"><![CDATA[<p>克隆和我们前面所讲的继承有一些区别，克隆是复制出来一个一模一样的目标对象，而克隆又分为浅层克隆和深层克隆。</p><p>• <strong><font color="red">浅层克隆</font></strong></p><p>克隆大致就是我们的源对象里面有什么属性，目标文件就有什么属性，依照这个原理，我们可以写出下面的代码：</p><pre><code>function clone(src, tar) {var tar = tar || {};// 如果没有tar则默认是一个空对象for(var prop in src) {      if(src.hasOwnProperty(prop)){           tar[prop] = src[prop];      } } return tar; }</code></pre><p>下面我们来测试一下:</p><pre><code>var obj = {      name: &apos;scarlett&apos;,      age: 123}var obj2 = {}clone(obj, obj2);console.log(obj2.name);// scarlett</code></pre><p>然后我们改变一下obj这个源对象的name：</p><pre><code>obj.name = &apos;test&apos;console.log(obj2.name);// scarlett</code></pre><p>我们可以发现，克隆出来的目标对象和本来的源对象之间没有关系了<br>但是，当我们有一个属性是引用值（数组或者对象）的时候，按照我们这种克隆方式，只是把这个引用值的指向赋给了新的目标对象，也就是说，我们一旦改变了源对象或者目标对象的引用值属性，另一个也会跟着改变，这一点就是浅层克隆的缺点。</p><p>• <strong><font color="red">深层克隆</font></strong></p><p><strong>思路:<br>    1.遍历对象<br>    2.判断是否是原始值 还是引用值<br>    3.判断引用值类似是数组还是对象<br>    4.建立相应的数组或对象<br>    5.递归</strong></p><pre><code>function clone(origin, target){    var target = target || {},//防止用户不传target参数         toStr = Object.prototype.toString,         arrStr = &quot;[object Array]&quot;;    for(var prop in origin){        if(origin.hasOwnProperty(prop)){            if( origin[prop] !== &quot;null&quot; &amp;&amp; typeof(origin[prop]) == &apos;object&apos;){                if(toStr.call(origin[prop]) == arrStr){                    target[prop] = [];                }else{                    target[prop] = {};                }                clone(origin[prop], target[prop]);            }else{                target[prop] = origin[prop];            }        }    }}</code></pre><p>现在我们来测试一下：</p><pre><code>var parent = {      name : &apos;ScarLet&apos;,      age : 123,      sex : &apos;male&apos;,      height : 190,      money: [1,2,3,4,5]}var child = {};deepCopy(parent,child);console.log(child.money);//1 2 3 4 5parent.money.push(10);console.log(child.money);// 1 2 3 4 5</code></pre><p>这个时候目标对象和源对象的引用值之间就没有了关系，自己都是独立值，可以进行修改了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;克隆和我们前面所讲的继承有一些区别，克隆是复制出来一个一模一样的目标对象，而克隆又分为浅层克隆和深层克隆。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;&lt;font color=&quot;red&quot;&gt;浅层克隆&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;克隆大致就是我们的源对象里面有什么属性，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>严格模式与try-catch</title>
    <link href="http://yoursite.com/2018/11/26/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8Etry-catch/"/>
    <id>http://yoursite.com/2018/11/26/严格模式与try-catch/</id>
    <published>2018-11-26T09:16:33.000Z</published>
    <updated>2018-12-18T09:32:43.278Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ES5-0严格模式"><a href="#ES5-0严格模式" class="headerlink" title="ES5.0严格模式"></a><font color="red">ES5.0严格模式</font></h4><p>• 浏览器 基于的es3.0的 + es5.0的新增方法 使用的<br>• es3.0 和 es5.0产生冲突的部分<br>• es5.0严格模式: 那么es3.0和es5.0产生冲突的部分就是用es5.0，否则会用es3.0</p><p><strong>es5.0严格模式的启动</strong>: 必须写在页面逻辑的最顶端 或 方法里面最顶端(局部)</p><pre><code>&quot;use strict&quot;;局部使用function test(){    &quot;use strict&quot;;    console.log(arguments.callee);}test();</code></pre><p><strong>严格模式下: • with, arguments.callee, caller(不能使用)<br>             • 变量赋值必须声明,局部this必须赋值<br>             • 拒绝重复属性和参数<br>             • es3.0 都不能使用eval();</strong></p><pre><code>如:function test(name, name){    &quot;use strict&quot;;    console.log(name);}test(1,2);var obj = {    name : &apos;123&apos;,    name : &apos;234&apos;}</code></pre><h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a><font color="red">try…catch</font></h4><p><strong>三段式:</strong></p><pre><code>try{}catch(e){    }finally{    }</code></pre><p><strong>error对象 ——&gt; error.massage error.name<br>Error.name的六种值对应的信息</strong></p><p>  1.EvalError: eval()的使用与定义不一致<br>  2.RangeError: 数值越界<br>  3.ReferenceError: 非法或不能识别的引用数值<br>  4.SyntaxError: 发生语法解析错误<br>  5.TypeError: 操作数类型错误<br>  6.URIError: URI处理函数使用不当</p><pre><code>console.log(b);// ReferenceError    没定义就使用test();        // ReferenceError var str = abcd;// ReferenceErrorfunction demo(){      :}//SyntaxError       语法解析错误//在try里面的发生错误,不会执行错误后的try里面的代码try{    console.log(&apos;a&apos;);    console.log(b);    console.log(&apos;c&apos;);}catch(e){    console.log(e.massage+&quot; &quot;+e.name);//出错走这里}    console.log(&apos;d&apos;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ES5-0严格模式&quot;&gt;&lt;a href=&quot;#ES5-0严格模式&quot; class=&quot;headerlink&quot; title=&quot;ES5.0严格模式&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;ES5.0严格模式&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;• 浏览器 基于的es3.0的 +
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>this</title>
    <link href="http://yoursite.com/2018/11/25/this/"/>
    <id>http://yoursite.com/2018/11/25/this/</id>
    <published>2018-11-25T09:16:33.000Z</published>
    <updated>2018-12-18T09:41:19.743Z</updated>
    
    <content type="html"><![CDATA[<h4 id="this"><a href="#this" class="headerlink" title="this"></a><font color="red">this</font></h4><p><strong>  1.函数预编译过程 this ——&gt;window<br>    2.全局作用域里   this ——&gt;window<br>    3.call/apply可以改变函数运行时this指向<br>    4.obj.func();    func()里面的this指向obj </strong>    </p><p><strong>总结: 四种this绑定的权重</strong></p><p><strong>  1,默认绑定(空函数执行,函数单纯执行,this指向window) 默认权重<br>    2,隐式帮定(谁调用this指向谁) 第三权重<br>    3,显式绑定 (call apply bind) 第二高权重<br>    4,new 绑定this 权重是最高的</strong></p><p><strong>升级知识：ES6箭头函数中的this如何邦定？<br>  1,箭头函数没有this 没有arguments surper(class)；<br>  2,箭头函数不能new ,不当成构造函数来 没有prototye；<br>  3,可以表示数据流向 方便JavaScript引擎优化扫码；</strong></p><p>例1</p><pre><code>var name = &quot;222&quot;;var a = {    name : &quot;111&quot;,    say : function(){        console.log(this.name);    }}var fun = a.say;fun();//预编译this指向windowa.say();//a执行this指向对象avar b = {    name : &quot;333&quot;,    say : function(fun){        fun();//预编译this指向window    }}b.say(a.say);b.say = a.say;b.say();//b执行this指向对象b</code></pre><p>例2</p><pre><code>var foo = 132;function print(){    this.foo = 234;    console.log(foo);}print();</code></pre><p>例3</p><pre><code>var foo = 132;function print(){    //var this = Object.create(print.prototype)    this.foo = 234;    console.log(foo);}new print();</code></pre><p>例4</p><pre><code>var a = 5;function test(){    a = 0;    console.log(a);    console.log(this.a);    var a;    console.log(a);}test();</code></pre><p>例5</p><pre><code> var a = 5;function test(){    a = 0;    console.log(a);    console.log(this.a);    var a;    console.log(a);}new test();</code></pre><p>例6</p><pre><code>var bar = {    a : &quot;002&quot;}function print(){    bar.a = &apos;a&apos;;    Object.prototype.b = &apos;b&apos;;    return function inner(){        console.log(bar.a);        console.log(bar.b);    }}print()();</code></pre><h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a><font color="red">call/apply</font></h4><p>call/apply的第一个参数会<font color="red">改变this的指向</font><br>• call 需要把实参按照形参的个数传进去<br>• apply 需要传一个arguments(数组)<br>其实方法的执行test()，实际上就是隐式转换成test.call();</p><pre><code>function Person(name, age){     this.name = name;     this.age = age;}var person = new Person(&apos;deng&apos;, 100);var obj = {};Person.call(obj, &apos;cheng&apos;, 300);console.log(obj.name);// &apos;cheng&apos;</code></pre><p>例1</p><pre><code>function Person(name, age, sex){    this.name = name;    this.age = age;    this.sex = sex;}         function Student(name, age, sex, tel, grade){    //this指向Student  本来是没有name/age/sex属性 用Person的方法实现自己的功能       //var this = {name : &quot;&quot;, age : &quot;&quot;, sex : &quot;&quot;}    Person.call(this, name, age, sex);    this.tel = tel;    this.grade = grade;}var student = new Student(&apos;sunny&apos;, 123, &apos;male&apos;, 139, 2017);</code></pre><p>例2</p><pre><code>function Wheel(wheelSize, style){    this.style = style;    this.wheelSize = wheelSize;}function Sit(c, sitColor){    this.c = c;    this.sitColor = sitColor;}function Model(height, width, len){    this.height = height;    this.width = width;    this.len = len;}function Car(wheelSize, style, c, sitColor, height, width, len){    Wheel.call(this, wheelSize, style);    Sit.call(this, c, sitColor);    Model.call(this, height, width, len);}var car = new Car(100, &quot;花里胡哨的&quot;, &quot;真皮&quot;, &quot;red&quot;, 1800, 1900, 4900);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;this&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;  1.函数预编译过程 this ——&amp;gt;window
      
    
    </summary>
    
    
  </entry>
  
</feed>
