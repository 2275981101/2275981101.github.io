<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.jpg?v=6.6.0">


  <link rel="mask-icon" href="/images/icon.jpg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
<meta property="og:type" content="website">
<meta property="og:title" content="welcome">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="welcome">
<meta property="og:description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="welcome">
<meta name="twitter:description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">



  <link rel="alternate" href="/atom.xml" title="welcome" type="application/atom+xml" />




  <link rel="canonical" href="http://yoursite.com/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>welcome</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">welcome</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">求知若饥，虚心若愚</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />Search</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/04/事件绑定/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/04/事件绑定/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">事件绑定</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-04 17:16:33" itemprop="dateCreated datePublished" datetime="2018-12-04T17:16:33+08:00">2018-12-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-25 10:28:24" itemprop="dateModified" datetime="2018-12-25T10:28:24+08:00">2018-12-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><font color="red">绑定事件</font></strong></p>
<p>1.<strong><font color="red">div.onclick(句柄方式)</font></strong> </p>
<p>虽然句柄方式的兼容性很好，但是一个元素的一种事件只能绑定一个函数。</p>
<pre><code>div.onclick = function(){
    console.log(&apos;a&apos;);
}
</code></pre><p>2.<strong><font color="red">div.addEventListener(‘事件类型’, 处理函数, false)</font></strong></p>
<p>可以给一个事件绑定多个处理函数</p>
<pre><code>div.addEventListener(&apos;click&apos;, function(){
    console.log(&apos;a&apos;);
}, false);
div.addEventListener(&apos;click&apos;, function(){
    console.log(&apos;b&apos;);
}, false);
</code></pre><p>3.<strong><font color="red">div.attachEvent(‘onclick’, function(){})</font></strong></p>
<p>这个方法是IE独有的方法，一个事件同样可以绑定多个处理函数。</p>
<pre><code>div.attachEvent(&apos;onclick&apos;, function (){
      console.log(&apos;a&apos;);
});
</code></pre><p>基本和addEventListener差不多，但是有一点区别是，<font color="red">当同一个函数绑定多次的时候，addEventListener是只执行一次，但是attachEvent会绑定几次执行几次</font>。</p>
<pre><code>function test () {
        console.log(&apos;a&apos;);
}
div.attachEvent(&apos;onclick&apos;, test);
div.attachEvent(&apos;onclick&apos;, test);
</code></pre><p>现在点击一次会打印两个a。</p>
<p>封装兼容性的 事件处理函数 </p>
<pre><code>function addEvent(elem, type, handle){
    if(elem.addEventListener){
        elem.addEventListener(type, handle, false);
    }else if(elem.attachEvent){
        elem.attachEvent(&apos;on&apos;+type, function(){
            handle.call(elem);
        })
    }else{
        elem[&apos;on&apos;+type] = handle;
    }
}
</code></pre><p>例: 使用原生js，addEventListener，为每一个li绑定一个点击事件，输出他们的顺序。这里就要注意这个题考察的不仅仅是绑定事件，更多的是<font color="red">闭包</font>的运用。</p>
<pre><code>&lt;li&gt;a&lt;/li&gt;
&lt;li&gt;b&lt;/li&gt;
&lt;li&gt;c&lt;/li&gt;
&lt;li&gt;d&lt;/li&gt;
&lt;script&gt;
    var li = document.getElementsByTagName(&apos;li&apos;);
        for(var i = 0;i &lt; li.length;i++){
            // 绑定事件 一但事件出现在循环里面要考虑是否出现闭包 
            (function(i){// 用立即执行函数解决
                li[i].addEventListener(&apos;click&apos;, function(){
                    console.log(i);
                }, false);
            }(i))
        }
&lt;/script&gt;
</code></pre><p><strong><font color="red">事件处理程序的运行环境</font></strong></p>
<p>1.句柄绑定方式中，函数里面的<font color="red">this指向元素本身</font>。</p>
<p>2.addEventListener方式中，函数里面的<font color="red">this也是指向元素本身</font>。</p>
<p>3.attachEvent中，函数里面的<font color="red">this指向的是window而不是元素本身</font>，这算是IE的一个BUG。针对这种情况，我们就需要把函数提取出来，然后在attachEvent的时候用<font color="red">call</font>来改变函数内部this的指向。</p>
<pre><code>div.attachEvent(&apos;onclick&apos;, function () {
       test.call(div);
}, false);
</code></pre><p><strong><font color="red">解除事件</font></strong></p>
<p>1.<strong><font color="red">ele.onclick = false/‘’/null;</font></strong></p>
<pre><code>var div = document.getElementsByTagName(&apos;div&apos;)[0];
div.onclick = function(){
    console,log(&apos;a&apos;);
    this.onclick = null;
}
</code></pre><p>2.<strong><font color="red">ele.removeEventListener(type, fn, false);</font></strong></p>
<p>针对的addEventListener的解除绑定。<br>但是这里要注意，只有命名函数才可以解除绑定，当绑定的函数是匿名函数的时候，是没有办法解除绑定的。</p>
<pre><code>div.addEventListener(&apos;click&apos;, test, false);
function test(){
    console.log(&apos;a&apos;);
}
div.removeEventListener(&apos;click&apos;, test, false);
</code></pre><p>3.<strong><font color="red">ele.detachEvent(‘on’ + type, fn);</font></strong></p>
<p>针对IE的attachEvent的解除绑定。也是同一个函数才可以解除绑定，匿名函数无法解除绑定。</p>
<p>封装兼容性的解除绑定函数：</p>
<pre><code>function remvoeEvent(ele, type, handle) {
    if(ele.removeEventListener) {
          ele.removeEventListener(type, handle, false);
    }else if (ele.detachEvent) {
          ele.detachEvent(&apos;on&apos; + type, handle);
    }else {
          ele[&apos;on&apos; + type] = null;
    }
}
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/03/事件分类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/03/事件分类/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">事件分类</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-03 17:16:33" itemprop="dateCreated datePublished" datetime="2018-12-03T17:16:33+08:00">2018-12-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-25 10:26:43" itemprop="dateModified" datetime="2018-12-25T10:26:43+08:00">2018-12-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a><font color="red">鼠标事件</font></h4><p>click、contextmenu(右键菜单)、mouseover、mouseout、mousedown、mousemove、mouseup移动端对应的(touchstart、touchmove、touchend)</p>
<p>• 所有的鼠标事件都有clientX和clientY，代表的是鼠标点击的位置，我们可以通过e.clientX和e.clentY来查看。</p>
<p>• 左键点击的顺序是：mousedown、mouseup、click</p>
<p>• 当我们同时绑定了click事件和mousedown事件后，如何解决mousedown和click的冲突问题？</p>
<pre><code>var firstTime = 0;
var laseTime = 0;
var key = false;
document.onmousedown = function(){
    firstTime = new Date().getTime();
}    
document.onmouseup = function(){
    laseTime = new Date().getTime();
    if(laseTime - firstTime &lt; 300){
        key = true;
    }
}
document.onclikc = function(){
    if(key){
        console.log(&apos;click&apos;);
        key = false;
    }
}
</code></pre><p>click事件永远都是左键，有左键和右键的区别的是mousedown事件。</p>
<p>再mousedown的事件对象中有一个属性叫做button，这个属性的值是0的时候代表我们按下的是左键，1的时候代表按下的中键，2的时候代表按下的是右键。</p>
<pre><code>document.onmousedown = function (e) {
  if (e.button == 0) {
      console.log(&apos;left&apos;);
  }else if (e.button == 1) {
      console.log(&apos;mid&apos;);
  }else {
      console.log(&apos;right&apos;);
  }
}
</code></pre><p>这里我们就可以重新回顾一下拖拽事件了：</p>
<pre><code>var div = document.getElementsByTagName(&apos;div&apos;)[0]
function drag(elem){
    var disX,
        disY;
    addEvent(elem, &apos;mousedown&apos;, function(e){// 之前封装的事件绑定函数
        var event = e || window.event;
        disX = event.clientX - parseInt(getStyle(elem, &apos;left&apos;));// 之前封装的查询元素样式函数
        disY = event.clientY - parseInt(getStyle(elem, &apos;top&apos;));
        addEvent(document, &apos;mousemove&apos;, mouseMove);
        addEvent(document, &apos;mouseup&apos;, mouseUp);
        stopBubble(e);
        cancelHandler(e);
    });
    function mouseMove(e){
        var event = e || window.event;
        elem.style.left = event.clientX - disX + &quot;px&quot;;
        elem.style.top = event.clientY - disY + &quot;px&quot;;
    }
    function mouseUp(e){
        var event = e || window.event;
        removeEvent(document, &apos;mousemove&apos;, mouseMove);
        removeEvent(document, &apos;mouseup&apos;, mouseUp);   
    }
}
</code></pre><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a><font color="red">键盘事件</font></h4><p>键盘事件主要有三个：keydown、keypress、keyup。<br>触发顺序分别是keydown &gt; keypress &gt; keyup。</p>
<p>keypress的范围和keydown有所区别：</p>
<p>keydown可以响应任意键盘按键，keypress只能响应字符类按键，也就是有ASCII码的字符的按键，像字母数字回车空格之类的。</p>
<p>事件对象的属性方面：只有keypress有charCode属性，这个属性代表的我们输入的这个字符的ASCII码，配合SHIFT之类的按键可以直接获取大写字母等。</p>
<p>keyCode和which每个方法都有，表示的是这个键的唯一标示，可以告诉浏览器我们按下的是键盘上的哪一个键，比如空格是32，32就代表空格。不过我们一般都用which，keyCode用的较少。</p>
<p>• String上有一个方法叫做fromCharCode，可以接受一个Unicode值（包含ASCII值），然后返回对应的字符串，我们可以配合这个方法和charCode来直接获取输入的字符。</p>
<pre><code>document.onkeypress = function(e){
    console.log(String.fromCharCode(e.charCode));
}
</code></pre><h4 id="文本操作事件"><a href="#文本操作事件" class="headerlink" title="文本操作事件"></a><font color="red">文本操作事件</font></h4><p>input,focus,blur,change</p>
<pre><code>&lt;input type=&quot;text&quot; value=&quot;请输入用户名&quot; style=&quot;color: #999;position: absolute;top: 200px&quot;
onfocus=&quot;if(this.value==&apos;请输入用户名&apos;){this.value=&apos;&apos;;this.style.color=&apos;#424242&apos;}&quot;
onblur=&quot;if(this.value==&apos;&apos;){this.value=&apos;请输入用户名&apos;;this.style.color=&apos;#999&apos;}&quot;&gt;
</code></pre><h4 id="窗体操作类-window上的事件"><a href="#窗体操作类-window上的事件" class="headerlink" title="窗体操作类(window上的事件)"></a><font color="red">窗体操作类(window上的事件)</font></h4><p><strong><font color="red">load事件</font></strong></p>
<p>这个事件window.onload和在body标签上写onload是一样的效果，作用是等页面中所有的东西都下载完成再执行里面的代码。</p>
<p><strong><font color="red">scroll事件</font></strong></p>
<p>这个方法是监听滚轮滚动的事件，我们可以用这个事件来写一个兼容版的fix定位。</p>
<pre><code>function beFixed(ele){
  var initPosX = ele.getPosition().w,
      initPosY = ele.getPosition().h;
  addEvent(window, &apos;scroll&apos;, function(e){
      ele.style.top =  initPosY + getScrollOffset().h + &apos;px&apos;;
      ele.style.left =  initPosX + getScrollOffset().w + &apos;px&apos;;
  })
}
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/02/脚本化CSS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/02/脚本化CSS/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">脚本化CSS</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-02 17:16:33" itemprop="dateCreated datePublished" datetime="2018-12-02T17:16:33+08:00">2018-12-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-25 10:29:42" itemprop="dateModified" datetime="2018-12-25T10:29:42+08:00">2018-12-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><font color="red">读写元素css属性</font></strong></p>
<p>每一个dom元素都有一个属性style，dom.style里面存放的这个元素的行间样式，我们可以通过这个属性来读写元素的行间样式。</p>
<p>1.碰到float这样的关键字属性的时候，前面要加一个css前缀。<font color="red">float — &gt; cssFloat</font></p>
<p>2.复合属性必须拆解，组合单词变成小驼峰式写法，写入的值必须是字符串格式.如</p>
<p>border: 1px solid red;只能写border-width、border-color、border-style。<br>background-color —&gt; backgroundColor;</p>
<p><strong><font color="red">查询计算样式</font></strong></p>
<pre><code>window.getComputedStyle(ele, null);
</code></pre><p>这个方法有两个参数，第一个参数是我们要获取的元素。<br>第二个参数是一个字符串，代表我们是否要获取这个元素上面的某一个伪元素，如果不的话，就填写null，否则就填写要获取的这个元素的哪一个伪元素。</p>
<p>这里的样式是<font color="red">取优先级最高的(即最终展示样式)</font>，不只是行间样式，所有的只要是表现出来的样式都可以获取出来。<br>同时，返回的计算样式的值都是<font color="red">绝对值</font>，没有相对单位。IE8 及 IE8以下不兼容</p>
<pre><code>div:after{
    width: 100px;
    height; 100px;
    background-color: red;
}
window.getComputedStyle(div, &apos;after&apos;).width;// 100px
</code></pre><p>IE8有一个特殊的查询样式<font color="red">ele.currentStyle</font>。</p>
<p>计算样式只读，IE独有的属性，返回的计算样式的值不是经过转换的绝对值</p>
<p>封装兼容性方法getStyle(obj,prop);</p>
<pre><code>function getStyle(obj, prop){
    if(window.getComputedStyle){
        return window.getComputedStyle(obj, null)[prop];
    }else{
        return obj.currentStyle[prop];
    }
}
</code></pre><p>例1: 我们可以写一个小方块运动的函数</p>
<pre><code>var div = document.createElement(&apos;div&apos;);
document.body.appendChild(div);
div.style.width = &quot;100px&quot;;
div.style.height = &quot;100px&quot;;
div.style.backgroundColor = &quot;blue&quot;;
div.style.position = &quot;absolute&quot;;
div.style.left = &quot;0&quot;;
div.style.top = &quot;0&quot;;
var speed = 1;
var time = setInterval(function(){
    speed += speed/20;
    div.style.left = parseInt(div.style.left) + speed +&quot;px&quot;;
    div.style.top = parseInt(div.style.top) + speed +&quot;px&quot;;
    if(parseInt(div.style.left)&gt;200&amp;&amp;parseInt(div.style.top)&gt;200){
        clearInterval(time);
    }
}, 50)
</code></pre><p>例2: 利用计数器变量 实现状态变换</p>
<pre><code>&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
    var div = document.getElementsByTagName(&apos;div&apos;)[0];
    div.style.width = &quot;100px&quot;;
    div.style.height = &quot;100px&quot;;
    div.style.backgroundColor = &quot;red&quot;;
    var count = 0;
    div.onclick = function(){
        count ++;
        if(count % 2 ==1){
            this.style.backgroundColor = &quot;green&quot;;
        }else{
            this.style.backgroundColor = &quot;red&quot;;
        }
    }
&lt;/script&gt;
</code></pre><p>例3: 实现用键盘控制小方块</p>
<pre><code>var div = document.createElement(&quot;div&quot;);
document.body.appendChild(div);
div.style.width = &quot;100px&quot;;
div.style.height = &quot;100px&quot;;
div.style.backgroundColor = &quot;green&quot;;
div.style.position = &quot;absolute&quot;;
div.style.left = &quot;0&quot;;
div.style.top = &quot;0&quot;;
document.onkeydown = function(e) {
  switch (e.which) {
    case 38:
      div.style.top = parseInt(div.style.top) - 5 + &quot;px&quot;;
      break;
    case 40:
      div.style.top = parseInt(div.style.top) + 5 + &quot;px&quot;;
      break;
    case 37:
      div.style.left = parseInt(div.style.left) - 5 + &quot;px&quot;;
      break;
    case 39:
      div.style.left = parseInt(div.style.left) + 5 + &quot;px&quot;;
      break;
  }
};
</code></pre><p>例4: 实现鼠标点击切换不同图片</p>
<pre><code>&lt;style&gt;
    .content{
        display: none;
        width: 200px;
        height: 200px;
        border: 2px solid red;
    }
    .active{
        background-color: yellow;
    }
&lt;/style&gt;

&lt;div class=&quot;wrapper&quot;&gt;
    &lt;button class=&quot;active&quot;&gt; 1 &lt;/button&gt;
    &lt;button&gt; 2 &lt;/button&gt;
    &lt;button&gt; 3 &lt;/button&gt;
    &lt;div class=&quot;content&quot; style=&quot;display: block;&quot;&gt;one&lt;/div&gt;
    &lt;div class=&quot;content&quot;&gt;two&lt;/div&gt;
    &lt;div class=&quot;content&quot;&gt;three&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    var btn = document.getElementsByTagName(&apos;button&apos;);
    var div = document.getElementsByClassName(&apos;content&apos;);
    for(var i = 0; i &lt; btn.length; i++){
        (function(n){ //循环里面绑定事件要考虑闭包。 解决方法:立即执行函数
            btn[n].onclick = function (){
                for(var j = 0; j &lt; btn.length; j++){
                    btn[j].className = &quot;&quot;;
                    div[j].style.display = &quot;none&quot;;
                }
                this.className = &quot;active&quot;;
                div[n].style.display = &quot;block&quot;;
            }
        }(i))   
    }
&lt;/script&gt;
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/滚动条与元素尺寸/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/01/滚动条与元素尺寸/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">滚动条与元素尺寸</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-01 17:16:33" itemprop="dateCreated datePublished" datetime="2018-12-01T17:16:33+08:00">2018-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-25 10:30:32" itemprop="dateModified" datetime="2018-12-25T10:30:32+08:00">2018-12-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="查看滚动条的滚动距离"><a href="#查看滚动条的滚动距离" class="headerlink" title="查看滚动条的滚动距离"></a><font color="red">查看滚动条的滚动距离</font></h4><p>js中有两套方法可以查看当前滚动条的滚动距离。</p>
<p>1.<strong>window.pageXOffset/window.pageYOffset</strong></p>
<p>这个方法可以查看滚动条的横轴和纵轴的滚动距离，但是很遗憾的是IE8以及以下的版本不兼容。用以下两种</p>
<p>2.<strong>document.body.scrollLeft/doucment.body.scrollTop<br>  和document.documentElement.scrollLeft/document.documentElement.scrollTop</strong></p>
<p>这里要说明的是，<font color="red">这两种方法要一起使用</font>，因为浏览器的兼容性问题，有的浏览器是document.body有值，有的是document.documentElement有值，<font color="red">但是所有的浏览器都只有一个有值，不会两个都有或者一个都没有</font>，而且这里的没有值不代表是null，而是0，因此我们使用的时候一般都是两个一起使用。</p>
<p>针对兼容性的问题，我们现在就可以封装一个函数，求滚动条滚动距离的方法。</p>
<pre><code>function getScrollOffset(){
    if(window.pageXOffset){
        return {
            x : window.pageXOffset,
            y : window.pageYOffset
        }
    }else{
        return {
            x : document.body.scrollLeft + document.documentElement.scrollLeft,
            y : document.body.scrollTop + document.documentElement.scrollTop
        }
    }
}
</code></pre><h4 id="查看视口的尺寸"><a href="#查看视口的尺寸" class="headerlink" title="查看视口的尺寸"></a><font color="red">查看视口的尺寸</font></h4><p><strong>window.innerWidth/window.innerHeight</strong><br>但IE8及IE8以下不兼容   </p>
<p><strong>标准模式下(有 &lt;!DOCTYPE html&gt; 声明)</strong><br><strong>document.documentElement.clientWidth/clientHeight</strong><br><strong>怪异模式下(无 &lt;!DOCTYPE html&gt; 声明)</strong><br><strong>document.body.clientWidth/clientHeight</strong></p>
<p>• 什么是怪异模式和标准模式呢？</p>
<p>浏览器的渲染模式有两种：<font color="red">标准模式和怪异模式</font>。我们常用的是标准模式，怪异模式是防止浏览器升级版本过高对后面版本你的代码不兼容，让浏览器可以向后兼容其他低版本的代码的法规则，比如IE6的怪异模式下可以兼容IE5个IE4的语法。</p>
<p>•  我们如何变成怪异模式呢？</p>
<p>其实很简单，只需要把我们html代码的第一行的<font color="red">&lt;!DOCTYPE HTML&gt;</font>去掉就可以变成怪异模式了，而加上这一行代码就可以变成标准模式。</p>
<p>• 如何判断怪异模式还是标准模式？</p>
<p>document上中有一个方法叫做<font color="red">compatMode</font>，当浏览器处于怪异模式的时候会返回字符串”<font color="red">BackCompat</font>“，在标准模式下可以返回”<font color="red">CSS1Compat</font>“，通过这个方法我们就可以判断了。</p>
<p>封装兼容性方法,返回浏览器视口尺寸</p>
<pre><code>function getViewportOffset(){
    if(window.innerWidth){
        return {
            x : window.innerWidth,
            y : window.innerHeight
        }
    }else{
        if(document.compatMode === &quot;BackCompat&quot;){
            return {
                w : document.body.clientWidth,
                h : document.body.clientHeight
            }
        }else{
            return {
                w : document.documentElement.clientWidth,
                h : document.documentElement.clientHeight
            }
        }
    }
}
</code></pre><h4 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸"></a><font color="red">查看元素的几何尺寸</font></h4><p><strong><font color="red">domEle.getBoundingClientRect()</font></strong></p>
<p>在获取的dom元素上，有一个getBoundingClientRect方法，这个方法可以获取到元素的宽高和左上点的位置以及有下点的位置（width、height、top、left、right、bottom）</p>
<p>但是<font color="red">老版本的IE浏览器没有实现width和height</font>，那么我们在老版本的IE计算宽高的时候就需要用<font color="red">bottom-top</font>和<font color="red">right-left</font>来计算宽高值了。</p>
<p>还有一点需要注意的是，这里的宽高也不是实时更新的，数据只是一个副本。<br>我们依然可以封装一个函数，可以返回元素的宽高。</p>
<pre><code>Element.getElementOffset() {
      var objData = this.getBoundingClientRect();
      if(objData.width) {
            return {
                  w: objData.width,
                  h: objData.height
            }
      }else {
            return {
                  w: objData.right - objData.left,
                  h: objData.bottom - objData.top
            }
      }
}
</code></pre><p><strong><font color="red">查看元素的尺寸</font></strong></p>
<p><strong>dom.offsetWidth<br>dom.offsetHeight</strong></p>
<p><strong><font color="red">查看元素的位置</font></strong></p>
<p><strong>dom.offsetLeft<br>dom.offsetTop</strong><br>对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。</p>
<p><strong>dom.offsetParent</strong><br>返回最近的有定位的父级，如无，返回body, body.offsetParent 返回null</p>
<p><strong><font color="red">滚动条滚动</font></strong></p>
<p>window上有三个方法<br><strong>scroll()、scrollTo()、scrollBy();</strong><br>三个方法功能类似，用法都是将x,y坐标传入。即实现让滚动轮滚动到当前位置。<br>区别：scrollBy()会在之前的数据基础之上做累加。</p>
<p>利用scrollBy() 快速阅读的功能</p>
<pre><code>function scrollBy(){
    var start = document.getElementsByTagName(&apos;div&apos;)[0];
    var stop = document.getElementsByTagName(&apos;div&apos;)[1];
    var timer = 0;
    var key = true;
    start.onclick = function(){
        if(key){
            timer = setInterval(function(){
                window.scrollBy(0, 10);
            }, 100);
            key = false;
        }
    }
    stop.onclick = function(){
        clearInterval(timer);
        key = true;
    }
}
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/30/Date对象与定时器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/30/Date对象与定时器/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">Date对象与定时器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-30 17:16:33" itemprop="dateCreated datePublished" datetime="2018-11-30T17:16:33+08:00">2018-11-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-25 10:33:28" itemprop="dateModified" datetime="2018-12-25T10:33:28+08:00">2018-12-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><font color="red">日期对象</font></strong></p>
<p>日期对象的方法在w3c上其实有介绍<br><a href="http://www.w3school.com.cn/jsref/jsref_obj_date.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/jsref/jsref_obj_date.asp</a></p>
<pre><code>var date = new Date();
date.getFullyear();
</code></pre><p><strong><font color="red">时间戳</font></strong></p>
<pre><code>var firstTime = new Date().getTime();
for(var i = 0;i &lt; 1000000000;i++){

}
var lastTime = new Date().getTime();
console.log(lastTime-firstTime);
</code></pre><p><strong><font color="red">定时器</font></strong></p>
<p><strong>setInterval()</strong><br>setInterval()里面的第二个参数是<font color="red">不能修改</font>就算你修改变量定时器内的time依然是1000,如下</p>
<pre><code>var time = 1000;
setInterval(function(){
    consloe.log(&quot;a&quot;);
}, time);
time = 2000;
</code></pre><p><strong>clearInterval();清除定时器</strong><br>1代表就是这个定时器,依次类推后面的定时器就是2…</p>
<pre><code>var i = 0;
setInterval(function(){
    console.log(i++);
    if(i &gt; 10){
        clearInterval(1);
    }
}, 100);
</code></pre><p><strong>setTimeout()和clearTimeout() 仅执行一次</strong></p>
<pre><code>var timer = setTimeout(function(){
   console.log(&quot;a&quot;);
}, 1000);
clearTimeout(timer);
</code></pre><p>setInterval() setTimeout() clearInterval() clearTimeout() 都是全局对象window上的方法<br>内部函数this指向window</p>
<p>例</p>
<pre><code>minutes: &lt;input type=&quot;text&quot; value=&quot;0&quot;&gt;
seconds: &lt;input type=&quot;text&quot; value=&quot;0&quot;&gt;
&lt;script&gt;
    var minutesNode = document.getElementsByTagName(&apos;input&apos;)[0];
    var secondsNode = document.getElementsByTagName(&apos;input&apos;)[1];
    var minutes = 0,
        seconds = 0;
    var timer = setInterval(function(){
        seconds ++;
        if(seconds == 60){
            seconds = 0;
            minutes ++;
        }
        secondsNode.value = seconds;
        minutesNode.value = minutes;
        if(minutes == 3){
            clearInterval(timer);
        }
    }, 100);
&lt;/script&gt;
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/29/DOM基础练习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/29/DOM基础练习/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">DOM基础练习</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-29 17:16:33" itemprop="dateCreated datePublished" datetime="2018-11-29T17:16:33+08:00">2018-11-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-19 16:33:55" itemprop="dateModified" datetime="2018-12-19T16:33:55+08:00">2018-12-19</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>遍历元素节点树</strong></p>
<pre><code>function retChild(node) {
     var child = node.childNodes,
           len = child.length;
     for(var i = 0; i &lt; len; i++){
           if(child[i].nodeType === 1) {
                console.log(child[i]);
               child[i].hasChildNodes() &amp;&amp; retChild(child[i]);
           }
      }
 }   
</code></pre><p><strong>返回元素elem的第n层父元素的节点</strong></p>
<pre><code>function retParent(elem, n){
    //与elem 解决兼容性容错  比如n足够大会报错而此时会返回null
    while(elem &amp;&amp; n){       
        elem = elem.parentElement;
        n --;
    }
    return elem;
}
var i = document.getElementsByTagName(&apos;i&apos;)[0];
</code></pre><p><strong>封装myChildren功能,解决以前部分浏览器的兼容性问题</strong></p>
<pre><code>Element.prototype.myChildren = function(){
    var child = this.childNodes;
    var len = child.length;
    var arr = [];
    for(var i = 0;i &lt; len;i++){
        if(child[i].nodeType == 1){
            arr.push(child[i]);
        }
    }
    return arr;
}
var div = document.getElementsByTagName(&apos;div&apos;)[0];
</code></pre><p><strong>封装函数,返回元素e的第n个兄弟元素节点n为正,返回后面的兄弟节点,n为负,返回前面的,n为0,返回自己</strong></p>
<pre><code>function retSibling(e, n){
    while( e &amp;&amp; n){//n = 0 循环退出     e &amp;&amp;: 解决兼容性容错
        if( n &gt; 0){
            if(0 &amp;&amp; e.nextElementSibling){
                e = e.nextElementSibling;
            }else{
                // 将e的下一个兄弟节点赋值给e 然后看e节点类型是否是元素节点 不是就一直重复
                // e &amp;&amp; :e如果为null会报错 e得有意义
                for(e = e.nextSibling; e &amp;&amp; e.nodeType != 1;e = e.nextSibling);
            }
            n --;
        }else{
            if(e.previousElementSibling){
                e = e.previousElementSibling;
            }else{
                for(e = e.previousElementSibling; e &amp;&amp; e.nodeType !=1;
                e = e.previousElementSibling);
            }
            n ++;
        }
    }
    return e;
}
</code></pre><p><strong>封装是否有元素子节点的方法</strong></p>
<pre><code>Element.prototype.hasChildren = function () {
      var child = this.childNodes,
            len = child.length;
      for( var i = 0; i &lt; len; i++){
            if(child[i].nodeType == 1) {
                  return true;
            }
      }
      return false;
}   
</code></pre><p><strong>封装insertAfter方法,与insertBefore方法类似</strong></p>
<pre><code>Element.prototype.insertAfter = function(targetNode, afterNode){
    var beforeNode = afterNode.nextElementSibling;
    if(beforeNode == null){//如果afterNode的下一个兄弟元素不存在
        this.appendChild(targetNode);//直接添加在最后面
    }else{
        this.insertBefore(targetNode, beforeNode);
    }
}
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/29/DOM基本操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/29/DOM基本操作/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">DOM基本操作</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-29 17:16:33" itemprop="dateCreated datePublished" datetime="2018-11-29T17:16:33+08:00">2018-11-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-25 10:33:15" itemprop="dateModified" datetime="2018-12-25T10:33:15+08:00">2018-12-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a><font color="red">什么是DOM</font></h2><p>• DOM的全称是<font color="red">Document Object Model 文档对象模型</font>，DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。</p>
<p>• DOM对象即为宿主对象，由浏览器厂商定义，用来操作html的css功能的一类对象和集合。不过浏览器厂商之间大部分都遵循w3c标准</p>
<p>• 简单来说，<font color="red">DOM就是用来操作html和css的，它是一系列对象的集合</font>。</p>
<h2 id="DOM如何操作HTML"><a href="#DOM如何操作HTML" class="headerlink" title="DOM如何操作HTML"></a><font color="red">DOM如何操作HTML</font></h2><p>document代表整个文档，它也是一个dom元素，我们dom对html的操作，即使对html的增删改查。下面我就介绍一下dom都是如何增删改查html的。</p>
<p>那么我们如何查看元素节点？</p>
<p>•  <font color="red"><strong>document.getElementById();</strong></font>   元素id 在Ie8以下的浏览器,不区分id大小写,而且也返回匹配name属性的元素<br>•  <font color="red"><strong>getElementsByTagName();</strong></font>    标签名<br>•  <font color="red"><strong>getElementByName();</strong></font>       需注意,只有部分标签name可生效(表单,表单元素,img,iframe)<br>•  <font color="red"><strong>getElementsByClassName();</strong></font>  类名 ie8和ie8以下的ie版本中没有,可以多个class一起</p>
<pre><code>var div = document.getElementsByClassName(&apos;demo demo1&apos;)[0];
</code></pre><p>注意: 以上都是’实时’的</p>
<p>•  <font color="red"><strong>querySelector();</strong></font><br>•  <font color="red"><strong>querySelectorAll();</strong></font></p>
<p>我们知道选择元素最强的是css，而这两个里面写的参数就是我们css选择器的写法。<br>不过querySelector永远选择一组里面的第一个，所以返回的不是一个类数组而是一个具体的元素。<br>而我们如果要返回一个类数组的集合的话，那么就用第二个querySelectorAll()方法。</p>
<pre><code>document.querySelector(&apos;div p #demo .demo&apos;);
</code></pre><p>不过这两个方法的问题在于，他们返回的不像前面四个是一个实时改变的元素，而是一个副本。当我们用这两个方法选择出来元素之后，我们把本身那个元素修改一下，会发现我们选择出来的那个元素没有变化。<br>注意: css选择器 在ie7和ie7以下的版本中没有</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a><font color="red">节点</font></h2><p>•  节点类型 ———— nodeType<br>•  元素节点 ———— 1<br>•  属性节点 ———— 2<br>•  文本节点 ———— 3<br>•  注释节点 ———— 8<br>•  document ———— 9<br>•  DocumentFragment ———— 11</p>
<p><strong><font color="red">节点的四个属性</font></strong></p>
<ol>
<li>nodeName     元素的标签名,以大写形式表示 只读</li>
<li>nodeValue    Text节点或Comment节点的文本内容 可读写</li>
<li>nodeType     该节点的类型 只读</li>
<li>attributes   Element 节点的属性集合</li>
</ol>
<p><strong><font color="red">节点的一个方法</font></strong><br>  Node.hasChildNodes();  判断是否有子节点</p>
<p><strong><font color="red">遍历节点树</font></strong></p>
<p>•  parentNode      ——&gt; 父节点<br>•  childNodes      ——&gt; 子节点<br>•  firstChild      ——&gt; 第一个子节点<br>•  lastChild       ——&gt; 最后一个子节点<br>•  nextSibling     ——&gt; 下一个兄弟节点<br>•  previousSibling ——&gt; 前一个兄弟节点</p>
<p><strong><font color="red">元素节点树的遍历</font></strong></p>
<p>•  parentElement          ——&gt; 返回当前元素的父元素节点 (IE不兼容)<br>•  children               ——&gt; 只返回当前元素的元素子节点<br>•  node.childElementCount === node.children.length当前元素节点的子元素节点个数(IE不兼容)<br>•  firstElementChild      ——&gt; 返回的是第一个元素节点(IE不兼容)<br>•  lastElementChild       ——&gt; 返回的是最后一个元素节点(IE不兼容)<br>•  nextElementSibling     ——&gt; 返回后一个元素节点（IE不兼容)<br>•  previousElementSibling ——&gt; 前一个兄弟元素节点（IE不兼容)</p>
<p>例</p>
<pre><code>&lt;div&gt;
    &lt;!-- This is comment --&gt;
    &lt;strong&gt;&lt;/strong&gt;
    &lt;span&gt;&lt;/span&gt;
&lt;/div&gt;
该div里面有多少个节点?
var div = document.getElementsByTagName(&apos;div&apos;);
div.childNodes;// 7个节点
</code></pre><h2 id="DOM树结构"><a href="#DOM树结构" class="headerlink" title="DOM树结构"></a><font color="red">DOM树结构</font></h2><p><img src="https://i.imgur.com/gLybWJ7.png" alt=""></p>
<p>1.<strong>getElementById</strong>         方法定义在Document.prototype上，即Element节点上不能使用。<br>2.<strong>getElementsByName</strong>       方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用(xml document,Element)<br>3.<strong>getElementsByTagName</strong>    方法定义在Document.prototype 和 Element.prototype上<br>4.<strong>HTMLDocument.prototype</strong>  定义了一些常用的属性，body,head,分别指代HTML文档中的<body><head><meta name="generator" content="Hexo 3.8.0">标签。<br>5.<strong>Document.prototype</strong>      上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代<html>元素<br>6.<strong>getElementsByClassName、querySelectorAll、querySelector</strong> 在Document,Element类中均有定义</html></head></body></p>
<h2 id="DOM的增删改查"><a href="#DOM的增删改查" class="headerlink" title="DOM的增删改查"></a><font color="red">DOM的增删改查</font></h2><p><strong><font color="red">增加操作</font></strong></p>
<p>1.<font color="red"><strong>创建元素节点 createElement</strong></font></p>
<pre><code>var div = document.createElement(&apos;div&apos;);
</code></pre><p>2.<font color="red"><strong>创建文本节点 document.createTextNode</strong></font></p>
<pre><code>var text = document.createTextNode(&apos;hello&apos;);   
</code></pre><p>3.<font color="red"><strong>创建注释节点 document.createComment</strong></font></p>
<pre><code>var comment = document.createComment(&apos;comment&apos;);   
</code></pre><p>4.<font color="red"><strong>创建文档碎片 document.createDocumentFragment</strong></font><br>这个方法可以创建一个文档碎片，我们在后面讲的有关提高性能的部分会用到这个方法。</p>
<p><strong><font color="red">插入操作</font></strong></p>
<p>1.<font color="red"><strong>appendChild(child);</strong></font></p>
<p>这个是父级调用的方法，它会将child元素插入到父级里面，而且是放到逻辑后面的位置上。</p>
<pre><code>div.appendChild(text);
div.appendChild(comment);
</code></pre><p>2.<font color="red"><strong>insertBefore(a, b);</strong></font></p>
<p>这个依然是父节点调用的方法，它的意思是将a插入到b前面的位置上，其中b要求是这个父级的子节点。这个方法可以记作为 insert a before b;</p>
<pre><code>var span = document.createElement(&apos;span&apos;);
div.insertBefore(span, comment);// 把一个span元素插入到了刚才的注释文本前面
</code></pre><p><strong><font color="red">删除操作</font></strong></p>
<font color="red"><strong>removeChild</strong></font>

<p>这个方法依然是父级调用的，参数就是要删除的子节点，其实实际上是剪切，这个方法会把我们删除掉的元素给返回，我们可以用一个变量去保存这个被删除的元素。</p>
<pre><code>var div = document.body.remove(div);
</code></pre><p><strong><font color="red">替换操作</font></strong></p>
<font color="red"><strong>replaceChild(new, origin)</strong></font>

<p>这个方法同样是父级调用，用新的元素new来替换原来的origin元素，原来的被替换掉的元素可以被返回，我们可以像删除操作那样用一个变量来保存。</p>
<h2 id="Element节点的属性和方法"><a href="#Element节点的属性和方法" class="headerlink" title="Element节点的属性和方法"></a><font color="red">Element节点的属性和方法</font></h2><p><strong>属性:</strong></p>
<p>1.<strong><font color="red">innerHTML</font></strong></p>
<pre><code>div.innerHML = &apos;&lt;div&gt;123&lt;/div&gt;&apos;;
</code></pre><p>我们可以直接通过这个属性来改变元素内部的结构和内容，不过注意它会直接删除掉以前的所有结构</p>
<p>2.<strong><font color="red">innerText/textContent</font></strong></p>
<p>innerText(火狐不兼容) / textContent(老版本IE不兼容)<br>这个属性可以直接调出来元素内部的文本信息，若果这个元素还有很多的子元素的话，那么会把子元素里面的文本信息一起返回。<br>不过需要注意的是，如果我们要改写innerText或者textContent的话，它会像innerHTML一样，<strong>先把内部的所有html结构先删除掉</strong>，然后再写入text文本</p>
<p>• 这里提一下，如果我们有很多字符串要添加到一个元素的内部的话，虽然用innerHTML或者innerText方法，但是却不是用innerHML += str的方法，因为+=操作符的效率极低，当字符串很多的时候会非常非常消耗性能。</p>
<p>遇到这种情况我们一般是用数组的join方法将字符串全部连接成一个字符串，然后一次性写入innerHTML。</p>
<p><strong>方法:</strong></p>
<p>1.<strong><font color="red">ele.setAttribute();</font></strong><br>这个方法可以设置元素的属性（特性），比如class、id等一些行间属性。</p>
<pre><code>div.setAttribute(&apos;id&apos;, &apos;demo&apos;);   
</code></pre><p>2.<strong><font color="red">ele.getAttribute();</font></strong><br>这个方法是获取元素的行间属性。</p>
<pre><code>&lt;div&gt;&lt;/div&gt;
&lt;span&gt;&lt;/span&gt;
&lt;strong&gt;&lt;/strong&gt;

var all = document.getElementsByTagName(&apos;*&apos;);//选中所有标签
for(var i = 0;i &lt; all.length;i++){
    all[i].setAttribute(&apos;this-name&apos;, all[i].nodeName);
}
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/28/数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/28/数组/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">数组</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-28 17:16:33" itemprop="dateCreated datePublished" datetime="2018-11-28T17:16:33+08:00">2018-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-25 10:25:16" itemprop="dateModified" datetime="2018-12-25T10:25:16+08:00">2018-12-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><font color="red">数组</font></h4><p><strong><font color="red">两种构造方法:</font></strong></p>
<p>1.字面量</p>
<pre><code>var arr = [1,2,,,,3,4];
</code></pre><p> 上面这种数组属于<font color="red">稀松数组</font></p>
<p>2.构造函数</p>
<pre><code>var arr = new Array(1,2,3,4);
</code></pre><p> JavaScript里的数组是基于对象的  即数组是一种特殊的对象</p>
<pre><code>var arr = new Array(10);
var arr1 = [10];
</code></pre><p> 这里arr创建了10个空数组，而arr1创建了1个参数为10的数组</p>
<h4 id="判断数组类型"><a href="#判断数组类型" class="headerlink" title="判断数组类型"></a><font color="red">判断数组类型</font></h4><p> 给定一个未知对象,判定他是否为数组 在es5中可以使用Array.isArray()函数来判断</p>
<pre><code>Array.isArray([]);// true
Array.isArray({});// false
Array.isArray(1);// false
</code></pre><p>在es5之前,大家可能想到利用typeof操作符来判断,但是无论是数组还是对象,均返回对象</p>
<pre><code>typeof [];// object
typeof {};// object
</code></pre><p>在es3中isArray()可以使用Object.prototype.toString.call(arr) === ‘[object Array]’代替</p>
<pre><code>Object.prototype.toString.call([]);// &apos;[object Array]&apos;
Object.prototype.toString.call({});// &apos;[object Object]&apos;
</code></pre><p><strong><font color="red">数组的添加和删除</font></strong></p>
<p>• <strong>添加</strong><br>    1.最简单的方法：为新索引赋值<br>    2.使用push()和unshift()方法</p>
<p>• <strong>删除</strong><br>    1.delete运算符删除数组元素(不会修改数组的length属性)<br>    2.使用pop()和shuift()方法</p>
<h4 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a><font color="red">数组的常用方法</font></h4><p> • <strong><font color="red">改变原数组: push, pop, shift, unshift, sort, reverse, splice</font></strong></p>
<p> • <strong><font color="red">不改变原数组: concat, join , split, toString, slice</font></strong></p>
<h4 id="push-在最后一位添加"><a href="#push-在最后一位添加" class="headerlink" title="push (在最后一位添加)"></a><font color="red">push (在最后一位添加)</font></h4><pre><code>var arr = [1,2];
Array.prototype.push = function (){
for(var i=0;i&lt;arguments.length;i++){
    this[this.length] = arguments[i];
}
    return this.length;
}
</code></pre><h4 id="pop-在最后一位剪切"><a href="#pop-在最后一位剪切" class="headerlink" title="pop (在最后一位剪切)"></a><font color="red">pop (在最后一位剪切)</font></h4><h4 id="shift-在最前面剪切"><a href="#shift-在最前面剪切" class="headerlink" title="shift (在最前面剪切)"></a><font color="red">shift (在最前面剪切)</font></h4><h4 id="unshift-在最前面添加"><a href="#unshift-在最前面添加" class="headerlink" title="unshift (在最前面添加)"></a><font color="red">unshift (在最前面添加)</font></h4><h4 id="reverse-反转"><a href="#reverse-反转" class="headerlink" title="reverse (反转)"></a><font color="red">reverse (反转)</font></h4><pre><code>var arr = [1, 2, 3, 4, 5];
arr.reverse();// [5, 4, 3, 2, 1]
</code></pre><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a><font color="red">splice</font></h4><p><strong>arr.splice(从第几位开始, 截取多少的长度, 在切口处添加新的数据);</strong></p>
<pre><code>var arr = [1, 1, 2, 2, 3, 3];
arr.splice(1, 2);// 删除 arr = [1,2,3,3]  
arr.splice(1, 1, 0,0,0);// 替换 arr = [1, 0, 0, 0, 2, 2, 3, 3]
arr.splice(3, 0, 4);// 等同于在第三位添加4
var arr = [1,2,3,4]
arr.splice(-1, 1);//arr = [1,2,3]   -1+length
arr.splice(-1, 2);//arr = [1,2] 
</code></pre><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort (排序)"></a><font color="red">sort (排序)</font></h4><pre><code>var arr = [1,3,5,4,10];
arr.sort();//按照ascll码排序
</code></pre><p><strong>自定义排序:<br>            1.必须写两形参<br>            2.看返回值:<br>                       1)当返回值为负数时,那么前面的数放在前面<br>                       2) 为正数,那么后面的数在前<br>                       3) 为0,不动</strong></p>
<pre><code>var arr = [3,1,5,10,4];
arr.sort(function(a, b){
    if(a &gt; b){  
        return 1;
    }else{
        return -1;
    }
});
//升序 a &gt; b ; 降序a &lt; b


var arr = [3,1,5,10,4];
arr.sort(function(a, b){
    return a - b;
});
// return a - b;升序    
// return b - a;降序  
</code></pre><p>给一个有序的数组,乱序:</p>
<pre><code>var arr = [1,2,3,4,5,6,7,8];
arr.sort(function(a, b){
    return Math.random()-0.5;
});
</code></pre><p>按照对象年龄大小排序:</p>
<pre><code>var cheng = {
    name : &quot;cheng&quot;,
    age : 30,
    sex : &quot;male&quot;
}
var deng = {
    name : &quot;deng&quot;,
    age : 50,
    sex : &quot;male&quot;
}
var zhang = {
    name : &quot;zhang&quot;,
    age : 40,
    sex : &quot;female&quot;
}
var arr = [cheng, deng, zhang];
arr.sort(function(a, b){
    return a.age - b.age;
});
</code></pre><p>按照字符串长度排序:</p>
<pre><code>function retBytes(str){
    var num = str.length;
    for(var i=0;i&lt;str.length;i++){
        if(str.charCodeAt(i)&gt;255){
            num ++;
        }
    }
    return num;
}
var  arr = [&apos;a邓&apos;, &apos;bd邓&apos;, &apos;cc老邓&apos;, &apos;ddddd&apos;, &apos;slkhadkhja&apos;];
arr.sort(function(a, b){
    return retBytes(a) - retBytes(b);
});
</code></pre><h4 id="concat-拼接-连接"><a href="#concat-拼接-连接" class="headerlink" title="concat (拼接/连接)"></a><font color="red">concat (拼接/连接)</font></h4><pre><code>var arr = [1,2,3];
var arr1 = [3,2,1];
var arr2 = arr.concat(arr1);// [1,2,3,3,2,1]
</code></pre><h4 id="slice"><a href="#slice" class="headerlink" title="slice "></a><font color="red">slice </font></h4><p>从该位开始截取, 截取到该位(不包括)</p>
<pre><code>var arr = [5,4,3,2,1,6];
var newArr = arr.slice(1, 4);// [4, 3, 2]
var newArr1 = arr.slice(1);// [4, 3, 2, 1, 6]
</code></pre><h4 id="join"><a href="#join" class="headerlink" title="join"></a><font color="red">join</font></h4><p>将数组中所有元素都转化成字符串并连接在一起，返回最后生成的字符串<br>可以选择一个可选的字符串在生成的字符串中来分隔数组的各个元素。<br>如果不指定使用分隔符，默认使用逗号。不修改原数组。</p>
<pre><code>var arr = [1,2,3];
var newArr = arr.join(&quot;-&quot;);//&quot;1-2-3&quot;
</code></pre><p>利用join(“”)可以实现大量字符串拼接</p>
<pre><code>var str = &quot;das&quot;;
var str1 = &quot;dqqd&quot;;
var str2 = &quot;fvmixk&quot;;
var str3 = &quot;qqqmlx&quot;;
var str4 = &quot;zmcxol&quot;;
var str5 = &quot;qpuh&quot;;
var str6 = &quot;lough&quot;;
var f = &quot;&quot;;
var arr = [str,str1,str2,str3,str4,str5,str6,f];
var newArr = arr.join(&quot;&quot;);
</code></pre><h4 id="split"><a href="#split" class="headerlink" title="split"></a><font color="red">split</font></h4><p>split()方法是按照给定的字符串将字符串分割成若干块来创建一个数组。</p>
<pre><code>var arr1 = newArr.split(&quot;-&quot;);//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]
</code></pre><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a><font color="red">indexOf</font></h4><p>返回某个指定的字符串值在数组中首次出现的位置，从头至尾搜索，没有则返回-1</p>
<pre><code>var arr = [1, 1, 2, 3, 5, 5];
arr.indexOf(1);// 0
</code></pre><h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a><font color="red">lastIndexOf</font></h4><p>返回某个指定的字符串值在数组中最后一次出现的位置，从尾至头搜索，没有则返回-1</p>
<pre><code>arr.lastIndexOf(5);// 5
</code></pre><p>同时我们可以在方法中传入两个参数，第一个参数代表需要搜索的值，第二个参数代表从哪一位开始搜索</p>
<pre><code>arr.indexOf(1,1);// 1
</code></pre><p>重写myIndexOf函数</p>
<pre><code>Array.prototype.myIndexOf = function(){
    var startIndex = 0;
    var args = arguments;
    var len = this.length;
    if(args[1]){// 如果有第二个参数 
        startIndex = args[1];
    }
    for(var i = startIndex;i &lt; len;i++){
        if(this[i] == args[0]){// 参数一
            return i;// 返回参数一的索引值
        }
    }
    return -1;
}
</code></pre><h4 id="reduce-和reduceRight"><a href="#reduce-和reduceRight" class="headerlink" title="reduce()和reduceRight()"></a><font color="red">reduce()和reduceRight()</font></h4><p>1.reduce()和reduceRight()方法使用指定的函数将数组元素进行组合,生成单个值。</p>
<p>reduce()可以传入两个参数,第一个是执行化简操作的函数.同样这个函数可以有参数,<br> • 第一个参数代表之前所有元素的累积结果<br> • 第二个参数代表当前进行运算的元素<br> • 第三个参数代表当前运算参数的索引值<br> • 第四个参数代表调用方法的原数组<br>第二个参数是可选的,是一个传递给函数的初始值.如果第二个参数有值,那么作为运算的初始值参与函数运算,如果第二个参数没有值,那么数组中的首位将作为函数运算的初始值,参与函数运算的数组其他位向后平移一位</p>
<p>reduceRight()和reduce()使用方法一致,但是reduceRight()进行函数运算从右到左.传参形式均一致.</p>
<pre><code>var arr = [1, 2, 3, 4, 5];
var b = arr.reduce(function(last, now, index, arr){
    console.log(last, now, index, arr);
    return last + now;
}, 10);
</code></pre><p>重写myReduce函数</p>
<pre><code>Array.prototype.myReduce = function(func, init){
    var len = this.length;
    var prev = init;
    var i = 0;
    if(init == undefined){// 不传第二个参数
        prev = this[0];
        i = 1;
    }
    for(i;i &lt; len;i++){
        prev = func(prev, this[i], i,this);
    }
    return prev;
};
</code></pre><p>例: 获得当前时间并将其转换成字符串形式,个位数用零补齐.例如8点45分零五秒转化成084505.</p>
<pre><code>var date = new Date();
var arr = [date.getHours(), date.getMinutes(), date.getSeconds()];
var str = arr.reduce(function(last, now){
    return last + (&apos;0&apos; + now).slice(-2);
}, &apos;&apos;);
</code></pre><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><font color="red">filter</font></h4><p><strong>数组的过滤</strong></p>
<p>filter()方法返回的数组元素是调用的数组的一个子集。<br>传递函数是用来逻辑判断的,该函数返回true或false.如果返回值为true或能转化成true的值,那么传递给判定函数的元素就是这个子集的成员,将被添加到一个作为返回值的数组中。<br>filter()方法的结果返回一个满足条件的数组，不修改原数组。<br>注意：filter()方法会跳过稀疏数组中缺少的元素，他的返回值总是非稀疏的。</p>
<pre><code>var arr = [0, 1, 2, 3, 45, 5];
var a = arr.filter(function(ele){
    return ele &gt; 3;
});
</code></pre><p>重写myFilter函数</p>
<pre><code>Array.prototype.myFilter = function(func){
    var newArr = [];
    for(var i = 0;i &lt; this.length;i++){// 遍历原数组
        if(func(this[i], i)){  
            newArr.push(this[i]);
        }
    }
    return newArr;
}
</code></pre><h4 id="every"><a href="#every" class="headerlink" title="every"></a><font color="red">every</font></h4><p><strong>数组的逻辑判定</strong></p>
<p>返回true或false,every()相当于与,当且仅当数组中的所有元素都满足调用函数的条件,返回true</p>
<pre><code>var arr = [1, 1, 2, 3, 45, 5, 5, 5];
arr.every(function(ele){
    return ele &lt; 10;
});// false

arr.every(function(ele){
    return ele &lt; 100;
});// true
</code></pre><h4 id="some"><a href="#some" class="headerlink" title="some"></a><font color="red">some</font></h4><p>返回true或false,some()相当于或,当数组中至少有一个元素调用判定函数返回true,它的返回值就是true,所有元素均不满足函数条件，则返回false</p>
<pre><code>var arr = [1, 1, 2, 3, 45, 5, 5, 5];
arr.some(function(ele){
    return ele &lt; 10;
});// true

arr.some(function(ele){
    return ele &lt; 0;
});// false
</code></pre><p>注意：一旦every()和some()确认返回值的时候就会停止遍历数组</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><font color="red">forEach</font></h4><p>数组遍历 forEach()方法</p>
<p>forEach()的使用方法：forEach方法从头至尾遍历数组，对每个元素调用指定的函数。<br>forEach方法传入参数为一个函数，函数 可以传入三个参数，按照顺序分别为,数组元素、元素索引和数组本身。不强制同时传入三个参数，可以按照需求传入参数个数。</p>
<p>重写myForEach函数</p>
<pre><code>Array.prototype.myForEach = function(fn){
    for(var i = 0;i &lt; this.length;i++){// this代表调用myForEach方法的数组
        fn(this[i], i);// 将数组的每一位this[i]及代表数组索引 i 作为函数参数
    }// 同时在for循环中执行参数fn函数
}
</code></pre><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a><font color="red">类数组</font></h4><p>我们知道有两种数据叫做数组和对象，但是我们其实可以用对象来模拟出数组的效果，我们把这种对象叫做类数组。我们前面提到的<font color="red">arguments实参列表就是一个类数组</font>。</p>
<p>类数组<font color="red">并不是一个数组</font>，但是它可以表现出数组的特性。</p>
<p><font color="red">属性要为索引(数字)属性</font>,<font color="red">必须有length属性</font>,最好加上push<br>好处:将数组和对象的方法都拼到一起,但不是所有方法都可以用</p>
<pre><code>var obj = {
    &quot;0&quot; : &apos;a&apos;,
    &quot;1&quot; : &apos;b&apos;,
    &quot;2&quot; : &apos;c&apos;,
    &quot;length&quot; : 3,
    &quot;push&quot; : Array.prototype.push,
    &quot;splice&quot; : Array.prototype.splice
}
Array.prototype.push = function (target){
    this[this.length] = target;
    this.length ++;
}
</code></pre><p>这样我们就创造了一个类数组，现在它就可以表现出数组的特性了。</p>
<pre><code>obj.push(d);
console.log(obj);
var obj = {
    &quot;0&quot; : &apos;a&apos;,
    &quot;1&quot; : &apos;b&apos;,
    &quot;2&quot; : &apos;c&apos;,
    &quot;3&quot; : &apos;d&apos;,
    &quot;length&quot; : 4,
    &quot;push&quot; : Array.prototype.push,
    &quot;splice&quot; : Array.prototype.splice
}
</code></pre><p>其实类数组的<font color="red">关键就在这个length属性</font>上，如果没有length属性，那么就是一个普通的对象，即使有push方法也不能使用。</p>
<p>现在我们有一个这样的题：</p>
<pre><code>var arrobj = {
    &quot;3&quot; : 1,
    &quot;4&quot; : 2,
    &quot;a&quot; : 3,
    &quot;b&quot; : 4,
    &quot;length&quot; : 2,
    &quot;push&quot; : Array.prototype.push,
}
arrobj.push(3);
arrobj.push(6);
</code></pre><p>仔细看一下push的方法之后，我们就知道了，最后的arrObj应该是这个样子的：</p>
<pre><code>var arrobj = {
    &quot;2&quot; : 3,
    &quot;3&quot; : 6,
    &quot;4&quot; : 2,
    &quot;a&quot; : 3,
    &quot;b&quot; : 4,
    &quot;length&quot; : 4,
    &quot;push&quot; : Array.prototype.push,
}
</code></pre><p>这里的length是2，所以一开始push(3)的时候把arrObj[2]改成了3，因为本身没有2这个下标，所以添加一条属性2:3，然后length变成了3，push(6)之后，arrObj[3]变成了6，本身有3这一条属性所以覆盖，然后把length变成4。</p>
<p>再来看一题：</p>
<pre><code>var obj = {
    &quot;2&quot; : &quot;a&quot;,
    &quot;3&quot; : &quot;b&quot;,
    &quot;length&quot; : 2,
    &quot;push&quot; : Array.prototype.push
}
obj.push(&apos;c&apos;);
obj.push(&apos;d&apos;);
</code></pre><p>执行obj.push(‘c’)之后 obj变成</p>
<pre><code>var obj = {
    &quot;2&quot; : &quot;c&quot;,
    &quot;3&quot; : &quot;b&quot;,
    &quot;length&quot; : 3,
    &quot;push&quot; : Array.prototype.push
}
</code></pre><p>接着执行obj.push(‘c’)之后 obj变成</p>
<pre><code>var obj = {
    &quot;2&quot; : &quot;c&quot;,
    &quot;3&quot; : &quot;d&quot;,
    &quot;length&quot; : 4,
    &quot;push&quot; : Array.prototype.push
}
</code></pre><h4 id="封装一个type工具方法"><a href="#封装一个type工具方法" class="headerlink" title="封装一个type工具方法"></a><font color="red">封装一个type工具方法</font></h4><p> 1.分两类  原始值 引用值<br> 2.区分引用值<br> 1)数组 2)对象 3)包装类</p>
<pre><code>function type(target){
    var template = {
        &quot;[object Array]&quot; : &quot;array&quot;,
        &quot;[object Object]&quot; : &quot;object&quot;,
        &quot;[object Number]&quot; : &quot;number - object&quot;,
        &quot;[object Boolean]&quot; : &quot;boolean - object&quot;,
        &quot;[object String]&quot; : &quot;string - object&quot;
    }
    if(target === null){
        return null;
    }else if(typeof(target) == &apos;object&apos;){
        var str = Object.prototype.toString.call(target);
        return template[str];
    }else{
        return typeof(target);
    }
}
</code></pre><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a><font color="red">数组去重</font></h4><pre><code>var arr = [1,1,1,1,1,2,2,2,2,1];
Array.prototype.unique = function(){
    var temp = {};
    var arr = [];
    var len = this.length;
    for(var i=0;i&lt;len;i++){
        if(!temp[this[i]]){
            temp[this[i]] = &quot;abc&quot;;
            arr.push(this[i]);
        }
    }
    return arr;
}
var newArr = arr.unique();
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/27/克隆算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/27/克隆算法/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">克隆算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-27 17:16:33" itemprop="dateCreated datePublished" datetime="2018-11-27T17:16:33+08:00">2018-11-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-25 10:29:19" itemprop="dateModified" datetime="2018-12-25T10:29:19+08:00">2018-12-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>克隆和我们前面所讲的继承有一些区别，克隆是复制出来一个一模一样的目标对象，而克隆又分为浅层克隆和深层克隆。</p>
<p>• <strong><font color="red">浅层克隆</font></strong></p>
<p>克隆大致就是我们的源对象里面有什么属性，目标文件就有什么属性，依照这个原理，我们可以写出下面的代码：</p>
<pre><code>function clone(src, tar) {
var tar = tar || {};// 如果没有tar则默认是一个空对象
for(var prop in src) {
      if(src.hasOwnProperty(prop)){
           tar[prop] = src[prop];
      }
 }
 return tar; 
}
</code></pre><p>下面我们来测试一下:</p>
<pre><code>var obj = {
      name: &apos;scarlett&apos;,
      age: 123
}
var obj2 = {}
clone(obj, obj2);
console.log(obj2.name);// scarlett
</code></pre><p>然后我们改变一下obj这个源对象的name：</p>
<pre><code>obj.name = &apos;test&apos;
console.log(obj2.name);// scarlett
</code></pre><p>我们可以发现，克隆出来的目标对象和本来的源对象之间没有关系了<br>但是，当我们有一个属性是引用值（数组或者对象）的时候，按照我们这种克隆方式，只是把这个引用值的指向赋给了新的目标对象，也就是说，我们一旦改变了源对象或者目标对象的引用值属性，另一个也会跟着改变，这一点就是浅层克隆的缺点。</p>
<p>• <strong><font color="red">深层克隆</font></strong></p>
<p><strong>思路:<br>    1.遍历对象<br>    2.判断是否是原始值 还是引用值<br>    3.判断引用值类似是数组还是对象<br>    4.建立相应的数组或对象<br>    5.递归</strong></p>
<pre><code>function clone(origin, target){
    var target = target || {},//防止用户不传target参数
         toStr = Object.prototype.toString,
         arrStr = &quot;[object Array]&quot;;
    for(var prop in origin){
        if(origin.hasOwnProperty(prop)){
            if( origin[prop] !== &quot;null&quot; &amp;&amp; typeof(origin[prop]) == &apos;object&apos;){
                if(toStr.call(origin[prop]) == arrStr){
                    target[prop] = [];
                }else{
                    target[prop] = {};
                }
                clone(origin[prop], target[prop]);
            }else{
                target[prop] = origin[prop];
            }
        }
    }
}
</code></pre><p>现在我们来测试一下：</p>
<pre><code>var parent = {
      name : &apos;ScarLet&apos;,
      age : 123,
      sex : &apos;male&apos;,
      height : 190,
      money: [1,2,3,4,5]
}
var child = {};
deepCopy(parent,child);
console.log(child.money);//1 2 3 4 5
parent.money.push(10);
console.log(child.money);// 1 2 3 4 5
</code></pre><p>这个时候目标对象和源对象的引用值之间就没有了关系，自己都是独立值，可以进行修改了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/26/严格模式与try-catch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wanghai">
      <meta itemprop="description" content="Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/26/严格模式与try-catch/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">严格模式与try-catch</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-26 17:16:33" itemprop="dateCreated datePublished" datetime="2018-11-26T17:16:33+08:00">2018-11-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-18 17:32:43" itemprop="dateModified" datetime="2018-12-18T17:32:43+08:00">2018-12-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="ES5-0严格模式"><a href="#ES5-0严格模式" class="headerlink" title="ES5.0严格模式"></a><font color="red">ES5.0严格模式</font></h4><p>• 浏览器 基于的es3.0的 + es5.0的新增方法 使用的<br>• es3.0 和 es5.0产生冲突的部分<br>• es5.0严格模式: 那么es3.0和es5.0产生冲突的部分就是用es5.0，否则会用es3.0</p>
<p><strong>es5.0严格模式的启动</strong>: 必须写在页面逻辑的最顶端 或 方法里面最顶端(局部)</p>
<pre><code>&quot;use strict&quot;;

局部使用
function test(){
    &quot;use strict&quot;;
    console.log(arguments.callee);
}
test();
</code></pre><p><strong>严格模式下: • with, arguments.callee, caller(不能使用)<br>             • 变量赋值必须声明,局部this必须赋值<br>             • 拒绝重复属性和参数<br>             • es3.0 都不能使用eval();</strong></p>
<pre><code>如:
function test(name, name){
    &quot;use strict&quot;;
    console.log(name);
}
test(1,2);

var obj = {
    name : &apos;123&apos;,
    name : &apos;234&apos;
}
</code></pre><h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a><font color="red">try…catch</font></h4><p><strong>三段式:</strong></p>
<pre><code>try{

}catch(e){

    }finally{

    }
</code></pre><p><strong>error对象 ——&gt; error.massage error.name<br>Error.name的六种值对应的信息</strong></p>
<p>  1.EvalError: eval()的使用与定义不一致<br>  2.RangeError: 数值越界<br>  3.ReferenceError: 非法或不能识别的引用数值<br>  4.SyntaxError: 发生语法解析错误<br>  5.TypeError: 操作数类型错误<br>  6.URIError: URI处理函数使用不当</p>
<pre><code>console.log(b);// ReferenceError    没定义就使用
test();        // ReferenceError 
var str = abcd;// ReferenceError

function demo(){
      :
}
//SyntaxError       语法解析错误

//在try里面的发生错误,不会执行错误后的try里面的代码
try{
    console.log(&apos;a&apos;);
    console.log(b);
    console.log(&apos;c&apos;);
}catch(e){
    console.log(e.massage+&quot; &quot;+e.name);//出错走这里
}
    console.log(&apos;d&apos;);
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Wanghai</p>
              <p class="site-description motion-element" itemprop="description">Wanghai个人站，主要涉及前端知识共享、实践教程、前沿技术共同学习等方面</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">45</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wanghai</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
